 - общее
 - библиотека AWT
 - сравнение AWT и Swing
 - библиотека Swing
        - JWindow, JFrame, JDialog
        - МЕНЕДЖЕРЫ  РАСПОЛОЖЕНИЯ Layout



----------------------------------------------- общее ------------------------------------------------------------------
        1. Есть две базовые библиотеки графических утилит, которые используются при создании графического интерфейса
    для приложений в Java:
            -  AWT (Abstract Window Toolkit);
            -  Swing

        2. Исторически первой появилась AWT, со временем ее дополнила библиотека Swing:
                - основные классы Swing созданы наследованием классов библиотеки AWT
                - в библиотеке Swing используется практически та же система обработки событий, что и в AWT

        3. Отличие между компонентами, созданными на основе классов библиотеки Swing (по сравнению с аналогичными
    компонентами, созданными на основе классов библиотеки AWT), то Swing - компоненты обладают большей гибкостью
    и разнообразием свойств.


----------------------------------------------- Java AWT ---------------------------------------------------------------
        1.  Первый графический интерфейс для Java была библиотека AWT (Abstract Window Toolkit) — инструментарий для работы
    с различными оконными средами

        2.  Библиотечные методы AWT создают и используют графические компоненты операционной среды
                   - с одной стороны, это хорошо, так как программа на Java похожа на остальные программы в рамках одной ОС
                   - но при запуске ее на другой платформе могут возникнуть различия в размерах компонентов и шрифтов,
                     которые будут портить внешний вид программы

        3. Чтобы обеспечить мультиплатформенность AWT интерфейсы вызовов компонентов были унифицированы,
    вследствии чего их функциональность получилась немного урезанной.
                   - из-за чего  набор компонентов получился довольно небольшой
                     (например, в AWT нет таблиц, а в кнопках не поддерживается отображение иконок)

        4. Таким образом, компоненты AWT не выполняют никакой "работы"
                - это просто «Java-оболочка» для элементов управления той операционной системы, на которой они работают
                - все запросы к этим компонентам перенаправляются к операционной системе, которая и выполняет всю работу

        5. Использованные ресурсы AWT старается освобождать автоматически.
                - это немного усложняет архитектуру и влияет на производительность,
                  поэтому написать что-то серьезное с использованием AWT будет несколько затруднительно



------------------------------------------- сравнение AWT и Swing ------------------------------------------------------
        1. Swing предоставляет более гибкие интерфейсные компоненты, по сравнению с более ранней библиотекой AWT.

        2. В отличие от AWT, компоненты Swing разработаны для кросс-платформенной работы,
   в то время как компоненты AWT повторяют интерфейс исполняемой платформы без изменений

        3. AWT использует только стандартные элементы операционной системы (ОС) для отображения,
   то есть для каждого элемента создается отдельный объект ОС (окно), в связи с чем,
   AWT не позволяет создавать элементы произвольной формы (возможно использовать только прямоугольные компоненты).

        4. Элементы управления на основе AWT всегда отображаются поверх Swing-элементов,
   т.к. все  Swing компоненты отображаются на поверхности контейнера

        5. Важнейшим отличием Swing от AWT является то, что компоненты Swing вообще не связаны с операционной системой
   и поэтому гораздо более стабильны и быстры.
                - такие компоненты в Java называются легковесными (lightweight)


----------------------------------------------- библиотека Swing -------------------------------------------------------
        1. Библиотека Swing предназначениа для создания графического интерфейса desktop'ых приложений, разрабатываемых на языке Java
                - содержит ряд графических компонентов (widget), таких как кнопки, поля ввода, таблицы и т.д.

        2. Swing относится к библиотеке классов JFC (Java Foundation Classes), которая представляет собой набор библиотек для разработки
    графических оболочек
                - в состав JFC входят библиотека:
                        - Java 2D   (используется для отрисовки)
                        - AWT (Abstract Window Toolkit)

        3. В качестве основы для своей библиотеки выбрали AWT, что видно на диаграмме наследования компонентов библиотеки Swing
                        Component   -  Container  -------  JComponent - остальные компоненты Swing
                        |        java.awt            |             java.swing

        4. Начиная с версии Java 1.2 (1998 год) Swing включён в Java Runtime Environment

        5. Swing позволяет легко создавать новые компоненты, наследуясь от существующих, и поддерживает различные стили и скины


        6. Look and Feel
                - архитектура Swing разработана таким образом, что можно изменять «look and feel» (L&F) приложения
                        - «Look»    -  определяет внешний вид компонентов
                        - «Feel»    -  их поведение


        7. JRE предоставляет следующие L&F:
                - CrossPlatformLookAndFeel  —   родной для приложений Java L&F, иначе называется Metal;
                                                    - используется по умолчанию и обеспечивает стандартное поведение компонентов
                                                и их внешний вид, вне зависимости от платформы
                - SystemLookAndFeel         —   родной для системы L&F;
                                                    - системный L&F определяется во время выполнения
                                                    - для Windows используется «Windows» L&F, который имитирует особенности
                                                  конкретной системы, на которой запущен
                                                    - для Linux и Solaris используется «GTK+», если установлен GTK+ 2.2 или более
                                                  поздняя версия, в противном случае используется «Motif»
                - Synth                     —   это основа для создания собственных L&F
                - Multiplexing              —   предоставляет возможность использования различных L&F одновременно.

            Таким образом, компоненты Swing поддерживают специфические динамически подключаемые виды и поведения (plugable look-and-feel),
        благодаря которым возможна адаптация интерфейса приложения к графическому интерфейсу платформы.
                - то есть к компоненту можно динамически подключить другой, специфический для операционной системы

            Таким образом, приложения, использующие Swing, могут выглядеть как "родные" приложения для данной операционной системы.


        8. Принцип Lightweight
            Означает, что Swing компоненты прорисовываются самими компонентами в родительском окне (например, на JFrame),
        без использования компонентов операционной системы.
            В отличие от «тяжелых» компонентов AWT, Swing приложение может иметься только одно окно

            В приложении могут сочетаться компоненты Swing и AWT.  Но это может порождать некоторые проблемы:
                 - компоненты AWT всегда перекрывают Swing элементы
                 - а также закрывают собой всплывающие меню JPopupMenu и JComboBox.
            Для предотвращения этого, у данного типа компонентов имеются методы setLightWeightPopupEnabled (boolean),
        позволяющие запретить использование «легковесных» всплывающих элементов
                 - при установке данного свойства в true AWT элементы не будут перекрывать меню

            Основным минусом таких «легковесных» (lightweight) компонентов является относительно медленная работа.
            Положительная сторона — универсальность интерфейса созданных приложений на всех платформах.


        9. Для того, чтобы создать приложение с графическим интерфейсом, необходимо:
                - создать сам интерфейс, со всеми необходимыми окнами, кнопками, полями и прочими элементами
                  (определить, как элементы интерфейса приложения будут отображаються на экране)
                - определить реакцию функциональных элементов интерфейса приложения на действия пользователя
                  (определить способ взаимодействия пользователя с приложением через элемент графического интерфейса)

        10. Все графические элементы условно можно разделить на два типа:
                - контейнеры    (содержат внути себя компоненты и другие контейнеры)
                       - контейнеры высшего уровня (top level containers) (классы JFrame, JWindow, JDialog)
                       - контейнеры низшего уровня
                - компоненты

        11. Cписок классов библиотеки Swing:
                - JComponent            -   суперкласс для кассов компонентов
                    - JWindow               -   контейнер для реализации окон (без строки названия и системных пиктограмм)
                    - JFrame                -   класс для создания окна
                    - JDialog               -   контейнер верхнего уровня для создания диалоговых окон

                    - JDesktopPane          -   контейнер, используемый для создания многодукментного интерфейса

                    - JMenu                 -   класс для создания стандартного меню
                    - JMenuBar              -   класс для создания меню верхнего уровня
                    - JMenuItem             -   класс для реализации пункта меню
                    - JToolBar              -   класс для создания панели инструментов

 
                        - JButton               -   класс предназначен для создания кнопок
                        - JCheckBox             -   класс для создания опций
                        - JCheckBoxMenuItem     -   класс для создания пункта меню в виде опций
                        - JColorChooser         -   класс для создания палитры выбора цвета
                        - JComboBox             -   класс для создания раскрывающихся списков
                        - JEditorPane           -   класс для создания панели редактирования с поддержкой стилей
                        - JFileChooser          -   класс для создания диалогового окна выбора фалов
                        - JFormattedTextField   -   класс для создания поля редактирования с поддержкой форматирования
                        - JInternalFrame        -   класс для создания внешнего окна, которое может содержать внутренние подокна
                        - JLabel                -   класс для создания меток
                        - JLayeredPaned         -   класс для управления механизмом перекрытия компонентов
                        - JList                 -   класс для создания списка

                        - JOptionPane           -   класс для работы с основными типами диалоговых окон
                        - JPanel                -   класс панели
                        - JPasswordField        -   класс для создания поля ввода для пароля
                        - JPopupMenu            -   класс для создания контекстного меню
                        - JProgressBar          -   класс для создания индикатора хода процесса
                        - JRadioButton          -   класс для создания переключателя опции
                        - JRadioButtonMenuItem  -   класс для создания меню в виде переключателя опций
                        - JRootPane             -   класс корневой папки
                        - JScrollBar            -   класс для создания полосы прокрутки
                        - JScrollPane           -   класс для создания панеи с полосой прокрутки
                        - JSeparator            -   класс для создания разделителя меню
                        - JSlider               -   класс для создани линейного регулятора
                        - JSpinner              -   класс для создани инкрементного регулятора (список с кнопками со стрелками, предназначенными для изменения значения в списке0
                        - JSplitPane            -   класс для создани специальной панели состоящей из двух частей с подвижным разделителем
                        - JTabbedPane           -   класс для создания панели с владками
                        - JTable                -   класс для создания таблицы
                        - JTextArea             -   класс для создания текстовой области
                        - JTextField            -   класс для создани поля редактирования
                        - JTextPane             -   класс текстовой панели широкого спектра
                        - JToggleButton         -   класс для создания кнопки с двумя состояниями

                        - JToolTip              -   класс предназначен для реализации оперативных подсказок для элементов интерфейса
                        - JTree                 -   класс для реализации древовидной иерархической структуры данных
                        - JViewport             -   класс реализации канала просмотра


        11.1  КОНТЕЙНЕРЫ ВЫСШЕГО УРОВНЯ -------- JWindow, JFrame, JDialog --------
                Они представляют собой окна операционной системы, в которых размещаются компоненты пользовательского интерфейса.
            К контейнерам высшего уровня относятся:
                        - окно JWindow
                        - окно JFrame
                        - диалоговое окно JDialog

                Контейнеры высшего уровня Swing представляют собой тяжеловесные компоненты и являются исключением из общего правила.
            Все остальные компоненты Swing являются легковесными.


            -------------------------------------- JWindow, JFrame, JDialog --------------------------------------------
                Окна являются основой пользовательского интерфейса любой операционной системы.
            Они визуально разделяют выполняемые в среде приложения.
                Окна, используемые в библиотеке Swing, мало чем отличаются от окон библиотеки AWT, которые представляют собой окна ОС

                Все окна библиотеки Swing — а к ним относятся:
                        - окно без рамки JWindow
                        - окно с рамкой JFrame
                        - диалоговое окно JDialog
                являются исключением из правила, согласно которому все компоненты Swing представляют собой легковесные компоненты
            и унаследованы от базового класса JComponent

                Окна Swing являются тяжеловесными контейнерами для размещения в них легковесных компонентов, которые ОС не видит


            -------------------------------------------- окно JWindow --------------------------------------------------
                «Родителем» всех окон Swing является окно без рамки и без элементов управления JWindow.

                Класс JWindow представляет собой окно без рамки и без элементов управления, предназначенных, к примеру,
            для его закрытия или перемещения
                Данный тип окна дает минимальные возможности по своей настройке, в отличие от чаще всего используемого окна JFrame

                Окно без рамки не часто требуется в программах
                Однако в отдельных случаях оно может быть полезно, особенно в тех случаях, когда необходимо ненадолго вывести на экран
            какую-либо информацию типа:
                        - заставки программы или
                        - подсказку для пользователя, и управлять окном с этой информацией не нужно

                Окна JWindow используются всплывающими меню JPopupMenu в тех ситуациях, когда в окне приложения не хватает места
            для размещения легковесного компонента в слое POPUP_LAYER многослойной панели, где всплывающие меню располагаются по умолчанию.
                В такой ситуации вместо легковесного компонента создается небольшое окно без рамки JWindow, которое можно разместить
            в любом месте экрана, потому что оно принадлежит операционной системе.
                В этом окне и размещается всплывающее меню.

            ПРИМЕР (использование окна без рамки)
                      - A1_ImageDraw
                      - A2_JWindowTest
                 Основная идея использования окна без рамки JWindow заключается в копировании части "изображения рабочего стола"
            в окно приложения
                 - В этом примере приложение наследуем от окна JWindow, чтобы удобнее вызывать методы этого класса и добавлять в окно компоненты
                 - Объект Robot необходимо создавать в блоке try ... catch,
                   т.к. его создание может быть запрещено менеджером безопасности, используемым виртуальной машиной Java
                 - Вырезаем часть изображения "рабочего стола" методом createScreenCapture() в стороне от местоположения нашего окна
                 - Затем в панель содержимого окна добавляется компонент ImageDraw, который и отображает вырезанное изображения рабочего стола
                 - После вывода окна на экран программа засыпает на 10 секунд, а потом заканчивает свою работу

                Прежде чем производить настройку окна, в примере вызывается конструктор базового класса ключевым словом super() без параметров
                На самом деле окна без рамки JWindow обязательно требуют при создании указывать своего «родителя» — окно с рамкой JFrame,
            что не всегда может быть неудобно.
                Специально для таких случаев в класс JWindow был добавлен конструктор без параметров, который создает вспомогательное невидимое окно
            JFrame и использует его как «родителя»
                После этого все окна без рамки, созданные таким образом, задействуют только это окно и экономят ресурсы

                Также с помощью конструктора без параметров создается окно JWindow, неспособное получать фокус ввода.
            Чаще всего именно такое поведение необходимо (ведь панелям инструментов, всплывающим заставкам и меню фокус ввода не нужен)
                При необходимости получения фокуса ввода, используйте метод setFocusableWindowState(true)


            -------------------------------------------- окно JFrame --------------------------------------------------
                Окно JFrame наследует свойства класса JWindow и представляет собой наиболее часто используемое в приложениях окно
            «общего назначения».

                Основные отличия окна JFrame от JWindow :
                    -   наличие рамки, которая позволяет изменять размер окна
                    -   наличие заголовка с названием приложения (заголовок может быть пустым)
                    -   возможность использования системного меню, позволяющее проводить манипуляции с окном и приложением
                    -   наличие кнопок управления для закрытия и свертывания окна

                Для размещения компонентов пользовательского интерфейса в подавляющем большинстве приложений применяется класс JFrame
            Разработчики Swing определили специальный метод закрытия окна setDefaultCloseOperation, существенно упрощающий эту операцию

                Наиболее полезные JFrame методы:
                    Эта группа методов позволяет задать позицию и размеры окна на экране:
                        -   setLocation()	    -   задает позицию окна
                        -   setSize()           -   позволяет указать его размеры
                        -   setBounds()         -   можно сразу задать прямоугольник, который займет окно на экране

                    -   раск()	    -   позволяет «упаковать» имеющиеся в окне компоненты, так чтобы они занимали столько места,
                                        сколько им необходимо
                                            компоненты при вызове этого метода переходят в «видимое» состояние, хотя и не появляются на экране
                                        до вызова одного из следующих методов:
                                                -   show()	        -   отображение окна на экране
                                                                            после вызова этих методов компоненты переходят в «видимое» состояние
                                                                        и начинают обслуживаться очередью событий
                                                                            к тому же метод проводит валидацию содержащихся в окне компонентов
                                                -   setVisible()    -   отображение окна на экране
                    -   dispose()	-   убирает окно с экрана (если оно в момент вызова метода видимо) и освобождает все принадлежащие ему ресурсы


                ПРИМЕР (простой JFrame  с обработкой события закрытия окна)
                            - B1_JFrameWindowListener

                     В примере создается окно JFrame с определением заголовка в конструкторе базового класса.
                         - для определения титульной строки окна можно также использовать метод setTitle() класса JFrame

                     Прежде чем задать размеры окна и отобразить его на экране, вызывается метод setDefaultCloseOperation().
                        - этот метод указывает, какое действие будет произведено при предварительной обработке события processWindowEvent()
                перед закрытием окна.
                        - по умолчанию используется константа HIDE_ON_CLOSE  -  убирающая окно с экрана при его закрытии
                          (можно использовать EXIT_ON_CLOSE, которое указывает, что при закрытии окна необходимо закончить работу приложения)
                        - в примере методу передается константа DO_NOTHING_ON_CLOSE - ничего не делать при закрытии окна

                     К окну JFrame подключается слушатель и обработка события закрытия окна выполняется в методе windowClosing.
                        - алгоритм обработки построен таким образом, что окно закрывается при третьей попытке
                        - номер попытки отображается в метке интерфейса

                     Для определения иконки окна необходимо использовать метод setIconImage()
                Иконка располагается на кнопке свернутого окна или в заголовке окна в нормальном состоянии

                     Из дополнительных возможностей окна с рамкой JFrame следует упомянуть о его способности «прятать» свои «украшения»:
                            - рамку и
                            - элементы управления окном.
                     Делает это метод JWindow


                ПРИМЕР (создание оконного интерфейса)
                            - B2_JFrameTest
                    - конструктор JFrame() без параметров создает пустое окно
                        (JFrame(String title) создает пустое окно с заголовком title)

                    - чтобы создать простейшую программу с пустым окном необходимо использовать следующие методы :
                         -  setSize(int width, int height)              -       определение размеров окна
                                    - если не определить размеры окна, то оно будет иметь нулевую высоту независимо от того, что в нем находится
                                  размеры окна включают не только «рабочую» область, но и границы и строку заголовка
                         -  setDefaultCloseOperation(int operation)     -       определение действия, которое необходимо выполнить
                                                                                при выходе из программы
                                                                                    для этого необходимо в качестве параметра operation
                                                                                передать константу EXIT_ON_CLOSE
                         -  setVisible(boolean visible)                 -       сделать окно видимым
                                    - по умолчанию окно создается невидимым.
                                    - чтобы отобразить окно на экране вызывается метод setVisible с параметром true
                                    - если вызвать его с параметром false, окно станет невидимым


            ---------------------------------------- диалоговое окно JDialog -------------------------------------------
                Диалоговые окна чаще всего используются в приложениях для получения дополнительной информации с целью:
                        - установки параметров приложения
                        - вывода важной вспомогательной/отладочной информации.

                Диалоговые окна, как правило, создаются модальными (modal), блокирующими доступ к остальным окнам приложения,
            пока пользователь не закончит работу с модальным диалоговым окном.
                Модальные диалоговые окна располагаются поверх основного окна приложения.

                Внешний вид диалоговых окон мало отличается от окон с рамкой JFrame, но обычно у них меньше элементов управления окна
            (чаще всего, имеется только кнопка закрытия окна) и отсутствует системное меню

                Диалоговые окна реализуются классом JDialog, унаследованном от базового класса окон JWindow и позволяющим создавать
            как обычные, так и модальные диалоговые окна.
                JDialog поддерживает как и JFrame закрытие окна, а в остальном сходен с другими окнами Swing.

                При создании диалоговых окон Swing необходимо указать «родительское окно», которым может быть окно с рамкой JFrame
            или другое диалоговое окно JDialog.
                Имеется также конструктор, не требующий «родительского» окна, но использующий вспомогательное прозрачное окно,
            о котором было сказано на странице «Окно без рамки JWindow».

                Swing предоставляет набор стандартных диалоговых окон JDialog для получения и вывода несложной информации
            Прежде чем создавать собственное диалоговое окно, следует рассмотреть возможность использования стандартного.


            ПРИМЕР (создания диалоговых окон JDialog)
                        - С1_JDialogTest

               В примере создаем окно с рамкой JFrame, в панели содержимого которого размещается две кнопки JButton
               По нажатию на кнопки создаются диалоговые окна в отдельном методе createDialog()
               Диалоговое окно с заданным заголовком JDialog может быть:
                        - модальным и
                        - немодальным
               Программа позволяет создать несколько немодальных окон одновременно, но только одно модальное.
               Немодальные окна не блокируют работу с основным окном приложения.
               При закрытии диалогового окна используется константа DISPOSE_ON_CLOSE, удаляющую окно после закрытия


            -------------------------------- события окон WindowListener, WindowFocusListener --------------------------
                Окна Swing (JWindow, JFrame, JDialog) поддерживают два типа событий :
                        -   WindowListener          -   позволяет узнать об изменениях в состоянии окна
                        -   WindowFocusListener     -   сообщает о получении или потере компонентами окна фокуса ввода

                Полный список методов данных слушателей можно найти в интерактивной документации Java.

                В интерфейсе слушателя WindowListener чаще остальных применяют
                        - метод windowClosing       -   вызываемый системой событий при закрытии окна

                К фрейму JFrame можно подключить слушателя окна, созданного на основе
            WindowAdapter (чтобы не реализовывать все определенные в интерфейсе WindowListener методы)
            и переопределить метод windowClosing, как это представлено в следующих строках кода :

                frame.addWindowListener (new WindowAdapter() {                                      // Добавляем слушателя событий от окна
                @Override
	            public void windowClosing(WindowEvent e) {
                    int res = JOptionPane.showConfirmDialog(null, "Выйти из программы?");           // Потверждение закрытия окна JFrame
                    if (res == JOptionPane.YES_OPTION)
                        System.exit(0);
                    }
                });

                При выходе из программы открывается диалоговое окно в панели JOptionPane и у пользователя спрашивается подтверждение,
            действительно ли он желает закончить работу с приложением.
                Если ответ положительный, то программа завершает работу.


            -------------------------------------------- оформление окон -----------------------------------------------
                Также есть возможность настраивать так называемое визуальное «оформление» окон:
                        - рамка
                        - элементы управления окном (кнопки закрытия или свертывания)
                        - системное меню

                Создание различных интерфейсов окон возможна благодаря усовершенствованиям в UI-представителе корневой панели JRootPane
                        - UI-представитель позволяет создавать специальные рамки, заголовок, системное меню и кнопки управления окном,
                    и размещать их в корневой панели нужным образом, используя специализированный менеджер расположения.
                        - менеджер расположения контролирует пространство корневой панели.
                        - кроме этого, при новом оформлении окон отключаются системные элементы окна.

                В классах JFrame и JDialog имеется статический метод:
                        - setDefaultLookAndFeelDecorated()  -   обеспечивающий возможность оформления всех создаваемых окон


                ПРИМЕР (оформления окон)
                        - D1_JFrameDecorations

                    В примере создается простое окно с рамкой и диалоговое окно
                    Перед создания окон вызывается метод setDefaultLookAndFeelDecorated(), означающий, что для создаваемых окон
                JFrame и JDialog потребуется специальное оформление.
                    Далее определяются размеры окон и они выводятся на экран

                    Следует обратить внимание на метод корневой панели setWindowDecorationStyle(), позволяющий настроить оформление окна.
                         - если окно с рамкой имеет только один тип оформления,
                      то диалоговые окна в зависимости от их цели (представление информации, сообщение об ошибке и тд) могут выглядеть по-разному
                         - в примере определено, что создаваемое диалоговое окно требуется для вывода информации, поэтому имеет такой вид

                    Специальное оформление окон используется как средство, позволяющее полностью, вплоть до окон, управлять внешним видом
                приложения
                    Создав собственного UI-представителя корневой панели, можно придать своему приложению уникальный вид,
                который с легкостью будет узнавать пользователь


        11.2 МЕНЕДЖЕРЫ  РАСПОЛОЖЕНИЯ Layout
              Менеджер расположения (layout manager) определяет, каким образом на форме будут располагаться компоненты
              Независимо от платформы, виртуальной машины, разрешения и размеров экрана менеджер расположения гарантирует,
        что компоненты будут иметь приоритет или близкий к нему размер и располагаться в том порядке, который был указан при создании программы

              Список менеджеров расположения:
                        - BorderLayout          -   полярное расположение
                        - FlowLayout            -   последовательное расположение
                        - GridLayout            -   табличное расположение
                        - GridBagLayout
                        - CardLayout
                        - BoxLayout
                        - GroupLayout
                        - SpringLayout
                        - собственный менеджер расположения

              В Swing менеджер расположения играет еще большую роль, чем обычно
              Он позволяет не только сгладить различия между операционными системами, но также дает возможность менять внешний вид приложения,
        не заботясь о том, как при этом изменяются размеры и расположение компонентов

              Поддержка менеджеров расположения встроена в базовый класс контейнеров java.awt.Container.
        Все компоненты библиотеки Swing унаследованы от базового класса JComponent, который, в свою очередь, унаследован от класса Container.
              Поэтому для любого компонента можно установить менеджер расположения или узнать, какой менеджер им используется в данный момент
        Для этого предназначены методы:
                        - setLayout()
                        - getLayout()

              Конечно, изменять расположение желательно только в контейнерах, которые предназначены для размещения в них компонентов
        пользовательского интерфейса, то есть:
                        - в панелях (JPanel) и
                        - окнах (унаследованных от класса Window).
               Не стоит менять расположение в кнопках или флажках, хотя такая возможность имеется.
               В стандартной библиотеке Java существует несколько готовых менеджеров расположения, и с их помощью можно реализовать
        абсолютно любое расположение


        ------------------------------------- вызов менджера расположения, revalidate ----------------------------------
               Контейнер окна вызывает методы менеджера расположения каждый раз при изменении своих размеров или при первом появлении на экране

               Кроме этого, можно программно запросить менеджер расположения заново расположить компоненты в контейнере:
                    - для этого служит так называемая проверка корректности (валидация) контейнера и содержащихся в нем компонентов

               Проверка корректности очень полезна, если интерфейс приложения меняется динамически
                    - например, если динамически меняются размеры компонентов (во время выполнения программы изменяется текст
                      надписи или кол-во столбцов таблицы — все это приведет к изменению размеров компонентов)
               После изменений компонентам может не хватать прежних размеров или наоборот, прежний размер будет для них слишком велик

               Для этого и предназначена проверка корректности
               Выполнить проверку корректности для любого компонента Swing, будь это контейнер или отдельный компонент,
        позволяет  метод revalidate(), определенный в базовом классе библиотеки JComponent

                Менеджер расположения размещает добавляемые в контейнер компоненты в некотором порядке согласно реализованного в нем алгоритма,
        и определяет их некоторый размер

                При этом он обычно учитывает определенные свойства компонентов:

                   - Предпочтительный размер    -      Размер, который идеально подходит компоненту
                                                            По умолчанию все размеры компонентов устанавливаются текущим менеджером внешнего вида
                                                       и поведения (look and feel manager), но можно их изменить
                                                            Предпочтительный размер можно изменить с помощью метода setPrefferedSize()

                   - Минимальный размер         -      Параметр определения минимального размера компонента
                                                            После достижения минимального размера всех компонентов контейнер больше не сможет
                                                       уменьшить свой размер
                                                            Минимальный размер также можно изменить используя метод setMinimumSize()

                   - Максимальный размер         -      Параметр определения максимального размера компонента при увеличении размеров контейнера
                                                            Например, максимальный размер текстового поля JTextField не ограничен
                                                        Чаще всего оно должно сохранять свой предпочтительный размер
                                                            Это можно исправить с помощью setMaximumSize(), устанавливающего максимальный размер.
                                                            Большая часть менеджеров расположения игнорирует максимальный размер,
                                                        работая в основном с предпочтительным и минимальным размерами

                   - Выравнивание по осям X и Y   -     Данные параметры нужны только менеджеру BoxLayout, причем для него они играют
                                                        важнейшую роль

                   - Границы контейнера           -     Эти параметры контейнера определяют размеры отступов от границ контейнера
                                                            Значения границ контейнера позволяет получить метод getInsets()
                                                            Иногда менеджеру расположения приходится их учитывать


        ------------------------------- описание бизнес-логики работы менеджера расположения ---------------------------
               Логика работы менеджера расположения происходит следующим образом :
                                Он ждет прихода сигнала от контейнера окна, требующего расположить в нем компоненты
                             Этому соответствует вызов метода layoutContainer() интерфейса LayoutManager
                             В методе layoutContainer() и происходит основная работа по расположению компонентов в контейнере

                        Менеджер расположения учитывает различные размеры и свойства компонентов и контейнера,
                    и должен расположить компоненты на определенных позициях в контейнере, вызывая для каждого из них метод setBounds(),
                    позволяющий указать в пикселах в системе координат контейнера прямоугольник, который будет занимать компонент.
                        Для сложных менеджеров расположения с гибким поведением это означает массу работы и сложные вычисления,
                    однако простые алгоритмы расположения компонентов реализовать совсем несложно.

               ПРИМЕР (разработки менеджера вертикального расположения компонентов VerticalLayout)
                                    - E1_VerticalLayout

                        Программа располагает компоненты вертикально с расстоянием между ними в 5 пикселов и использует для всех компонентов
                    предпочтительный размер

                        Менеджер расположения VerticalLayout реализует интерфейс LayoutManager.
                    Самым важным методом является layoutContainer(), который определяет расположения всех компонентов, содержащиеся в контейнере

                        Алгоритм функционирования менеджера расположения не сложный:
                            -   размещение компонентов по вертикали, отделяя их друг от друга расстоянием в 5 пикселов
                            -   все компоненты имеют предпочтительный размер

                        Чтобы реализовать алгоритм выполняются следующие шаги :
                            -   получение массива компонентов - метод контейнера getComponents()
                            -   организация цикла перебора компонентов
                            -   определение предпочтительного размера для каждого из компонентов - метод getPreferredSize()
                            -   определение позиции компонента на экране методом setBounds()
                            -   смещение текущей вертикальной координаты Y, увеличением ее значения на высоту очередного компонента
                                с учетом «декоративного» расстояния в 5 пикселов.

                        Таким образом, менеджер VerticalLayout разместит все компоненты контейнера друг над другом на расстоянии в 5 пикселов.
                    Следует обратить внимание, что компоненты отделены и от левой границы контейнера

                        - addLayoutComponent()      -    предназначен для добавления компонентов в список менеджера расположения
                        - removeLayoutComponent()   -    для удаления компонентов из списка
                        - addLayoutComponent()      -    позволяет ассоциировать с компонентом строку, которая может быть использована
                                                         менеджером расположения как рекомендация относительно того,
                                                         где именно необходимо разместить данный компонент

                        Пример менеджера расположения в отличие от BorderLayout не поддерживает подобных рекомендаций

                        Две функции менеджера (предпочтительный preferredLayoutSize() и минимальный minimumLayoutSize())
                    сообщают размеры контейнера
                        Для нашего простого менеджера расположения минимальный и предпочтительный размеры контейнера совпадают,
                    их вычисляет метод calculateBestSize()
                        Для вычисления оптимального размера контейнера в цикле выполняется поиск компонента с самой большой длиной
                        К найденной длине добавляется 5 пикселов в качестве отступа от левой границы контейнера и получаем оптимальную длину
                    контейнера
                        Для высоты вычисления чуть сложнее :
                            -   необходимо сложить высоты всех находящихся в контейнере компонентов, а также прибавлять к ним расстояние в
                                5 пикселов между всеми компонентами.
                            -   полученная сумма и является оптимальной высотой контейнера.


               -------------------------------- полярное расположение BorderLayout -------------------------------------
                    Менеджер BorderLayout специально предназначен для обычных и диалоговых окон
               Он позволяет быстро и просто расположить наиболее часто используемые элементы любого окна:
                        -   панель инструментов,
                        -   строку состояния и
                        -   основное содержимое.
                    Для этого BorderLayout разбивает окно на четыре области, а все оставшееся место заполняется компонентом,
               выполняющим основную функцию приложения - в редакторе это будет текстовое поле, в многооконном приложении — рабочий стол

                    Менеджер расположения BorderLayout иммет отличия от остальных.
                    Чтобы добавить с его помощью компонент в методе add() необходимо использовать дополнительный параметр,
               который определяет область контейнера для размещения компонента.
                    В таблице перечислены допустимые значения этого параметра:
                        -   BorderLayout.NORTH  -   компонент располагается вдоль верхней границы окна и растягивается на всю его ширину
                                                    обычно в этом месте размещается панель инструментов
                        -   BorderLayout.SOUTH  -   компонент располагается вдоль нижней границы и растягивается на всю ширину окна.
                                                    такое положение характерно для строки состояния
                        -   BorderLayout.WEST   -   компонент располагается вдоль левой границы окна и растягивается на всю его высоту;
                                                    при этом учитываются размеры северных и южных компонентов, имеющих приоритет.
                        -   BorderLayout.EAST	-   компонент располагается вдоль правой границы окна
                                                    в остальном его расположение аналогично западному компоненту
                        -   BorderLayout.CENTER	-   компонент помещается в центр окна, занимая максимально возможное пространство

                    Рекомендации :
                        -   на север помещайте панель инструментов вашего приложения
                        -   на юг помещайте строку состояния.
                        -   оставляйте западные и восточные зоны окна свободными — только в этом случае панель инструментов можно будет
                            перетаскивать
                        -   для главного окна вашего приложения всегда используйте расположение BorderLayout

               ПРИМЕР (создается окно JFrame, в котором менеджер BorderLayout используется по умолчанию)
                                    - E2_BorderLayoutTest

                        Во все доступные зоны добавляются компоненты
                        В примере метод установки менеджера расположения setLayout() не вызывался.
                        В окнах JFrame (также в окнах JWindow и JDialog) расположение BorderLayout применяется автоматически c принимаемой
                    по умолчанию константой Center
                        При использовании строк в качестве параметров метода add() надо быть внимательным.
                            - cо строкой легко сделать трудно обнаруживаемую ошибку, в то время как ошибку при использовании констант
                              сразу же обнаружит компилятор

                        Возможности полярного расположения довольно ограничены
                        Оно создано специально для окон, но иногда может помочь и в более сложных случаях


               ----------------------------- последовательное  расположение FlowLayout ---------------------------------
                    Менеджер последовательного расположение FlowLayout размещает компоненты в контейнере слева направо, сверху вниз
               При полном заполнении компонентами строки контейнера FlowLayout переходит на следующую строку вниз.

                    Данное расположение устанавливается по умолчанию в панелях JPanel.

                    Основным свойством FlowLayout является определение предпочтительного размера компонентов.
               Например, размер метки с текстом JLabel соответствует размеру текста.

               ПРИМЕР (FlowLayout с последовательным расположением компонентов)
                                    - E3_FlowLayoutTest

                       Конструктор класса FlowLayout имеет три перегруженные версии:
                            -   без параметров,
                            -   с параметрами выравнивания компонентов,
                            -   с параметрами выравнивания компонентов и расстояний между ними.

                       В примере использована вторая версия, устанавливающая последовательное расположение по центру.

                       При запуске программы размер окна позволил менеджеру FlowLayout разместить компоненты в одной строке,
                   но при уменьшении размера окна компоненты смещаются в следующую строку

               При последовательном расположении менеджер FlowLayout всегда сохраняет предпочтительный размер компонентов.
                    - если места в контейнере становится мало, то FlowLayout просто прячет «лишние» компоненты, а не уменьшает их размеры

                    Также к важным свойствам менеджера расположения FlowLayout следует отнести то, что при вызове
               метода preferredLayoutSize() или minimumLayoutSize(), позволяющего узнать предпочтительный и минимальный размеры контейнера,
               в котором этот менеджер действует, метод возвращает размер, соответствующий ситуации расположения всех компонентов в одну строку
                    Это особенно важно при совмещении последовательного расположения с другими вариантами расположения.
                    Вследствие этого свойства менеджеры других вариантов расположения будут стараться найти достаточно места для
               размещения компонентов в одну строку
                    Поэтому использовать последовательное расположение следует только в контейнере, где достаточно места, или там,
               где контейнеру некуда будет «прятать» свои компоненты.
                    Пример совмещении последовательного расположения с табличным представлен в примере:
                                - E5_ManagerLayoutsTest
                    Тем не менее, этот простотой менеджер расположения FlowLayout очень хорош при организации несложных вариантов расположения


               ---------------------------------- табличное расположение GridLayout ------------------------------------
                    Менеджер расположения GridLayout представляет контейнер в виде таблицы с ячейками одинакового размера.
                        - количество строк и столбцов можно указать в конструкторе
                        - имеется возможность задать произвольное количество либо строк, либо столбцов, но не одновременно
                        - все ячейки таблицы имеют одинаковый размер, равный размеру самого большого компонента, находящегося в таблице

               ПРИМЕР (табличное расположение компонентов - GridLayout)
                                    - E3_FlowLayoutTest

                    В примере задается произвольное количество столбцов
                        - для этого в конструкторе вместо конкретного числа столбцов указывается ноль.
                        - аналогично можно задать и произвольное количество строк в таблице

                    Если произвольно увеличить размер окна, то менеджер расположения GridLayout также занимает все место,
               доступное в данный момент в окне, и пропорционально увеличивает размеры компонентов.
                    Если уменьшить окно, то GridLayout также пропорционально уменьшит размеры компонентов.

                    Основные свойства менеджера табличного расположения :
                        -   все компоненты имеют одинаковый размер
                                доступное пространство контейнера с табличным расположением разбивается на одинаковое количество ячеек,
                            в каждую из которых помещается компонент
                        -   все компоненты всегда выводятся на экран вне зависимости от размеров окна

                    Чаще всего совмещают панели с различными менеджерами расположения для получения необходимого интерфейса окна.

               ПРИМЕР (совмещения табличного GridLayout и последовательного FlowLayout расположения компонентов)
                                    - E5_ManagerLayoutsTest

                        В этом примере совмещаем менеджер табличного расположения компонентов GridLayout с менеджером последовательного
                    расположения FlowLayout, которое никогда не делает содержащиеся  в нем компоненты больше их предпочтительного размера
                        Для этого создадим элемент пользовательского интерфейса, встречающийся практически в любом диалоговом окне,
                    а именно строку кнопок (кнопки ОК и Отмена).
                        Табличное расположение придаст кнопкам одинаковый размер, а последовательное расположение не даст им «расплыться»
                    и заодно выровняет их по правому краю.

                        В данном примере как бы не изменять размер окна полярное расположение заставит панель с кнопками разместиться
                    вдоль нижней границы окна, а последовательное расположение заставит их прижаться к правому краю.


               --------------------------------- менеджер расположение GridBagLayout -----------------------------------
                    Менеджер расположения GridBagLayout подобно табличному менеджеру устанавливает компоненты в таблицу.
               Но он дает возможность определять для компонентов разную ширину и высоту колонок и строк таблицы.
               Фактически GridBagLayout позволяет получить абсолютно любое расположение компонентов.

               ПРИМЕР (использования менеджера расположения GridBagLayoutTest)
                                    - E6_GridBagLayoutTest

                        При использовании менеджера расположения GridBagLayout необходимо настраивать класс GridBagConstraints
                   для каждого добавляемого компонента, что существенно усложняет процесс разработки.
                        Поэтому GridBagLayout используется большей частью при автоматизированной разработке интерфейса,
                   при которой мышью указывается расположение компонентов, а система требуемым образом настраивает менеджер GridBagLayout


               --------------------------------- менеджер расположение CardLayout --------------------------------------
                    Менеджер CardLayout можно использовать для создания так называемых вкладок (tabs), выбирая которые будут избранно
               открываться разные панели, занимающие одно и то же место в интерфейсе окна.
                    Данную задачу можно решить с использованием класса JTabbedPane, организовывающего управление панелями с вкладками

               ПРИМЕР (использования менеджера расположения CardLayoutTest)
                                    - E7_CardLayoutTest


               ---------------------------------- менеджер расположение BoxLayout --------------------------------------
                    Менеджер расположения BoxLayout позволяет управлять размещением компонентов:
                        - либо в вертикальном,
                        - либо в горизонтальном направлениях
                    и управлять пространством между компонентами, используя вставки.
                    Для размещения компонентов:
                        - в вертикальной плоскости необходимо конструктору передать константу   - BoxLayout.Y_AXIS,
                        - в горизонтальной                                                      - BoxLayout.X_AXIS.

               ПРИМЕР (использования менеджера расположения BoxLayout)
                                    - E8_BoxLayoutTest


               ---------------------------------- менеджер расположение GroupLayout ------------------------------------
                    Менеджер расположения компонентов GroupLayout раскладывает компоненты по группам.
               Группы:
                    - имеют горизонтальное и вертикальное направление
                    - и могут быть параллельными и последовательными.
                            - в последовательной группе у каждого следующего компонента координата вдоль оси на единицу больше
                                (имеется в виду координата в сетке)
                            - в параллельной – компоненты имеют одну и ту же координату

               ПРИМЕР (использования менеджера расположения GroupLayout)
                                    - E9_GroupLayoutTest


               ---------------------------------- менеджер расположение SpringLayout -----------------------------------
                    Несмотря на универсальность менеджера расположения SpringLayout, действие его весьма специфично и не похоже на действие
               ни одного из уже рассмотренных выше менеджеров расположения.

                    С каждым компонентом ассоциируется особый информационный объект SpringLayout, который позволяет задать расстояние (в пикселах)
               между парой границ различных компонентов.
                    Границ у компонента четыре — это его
                        -   северная,
                        -   восточная,
                        -   западная и
                        -   южная стороны
                    Можно задавать расстояние и между границами одного и того же компонента:
                        -   к примеру, задав расстояние между северной и южной сторонами одного компонента, вы укажете его высоту.
                    По умолчанию все компоненты имеют предпочтительный размер, однако SpringLayout учитывает и два остальных размера,
               не делая компоненты меньше минимального и больше максимального размеров.

                    На первом этапе работы менеджера SpringLayout все компоненты находятся в начале координат контейнера и имеют
               предпочтительный размер
                    Чтобы разместить их по нужным позициям, обычно проводят следующие действия:
                        -   первый компонент отделяют некоторым расстоянием от границы контейнера,
                        -   второй отделяют от первого расстоянием между нужными границами,
                        -   далее размещают третий компонент и т.д.

               ПРИМЕР (использования менеджера расположения SpringLayout)
                                    - E10_SpringLayoutTest


               ------------------------------- интерфейс диалогового окна авторизации ----------------------------------
               ПРИМЕР (диалогового окна авторизации LoginDialog)
                                    - E10_SpringLayoutTest


        11.3  JMenu, JMenuBar, JToolBar
               ----------------------------------------- JMenu ---------------------------------------------------------
                    Компонент меню JMenu позволяет создать набор элементов (пунктов меню) и представить их в интерфейсе окна
                    Элемент меню представляет собой кнопку, унаследованную от класса AbstractButton и отличающуюся от кнопок, флажков
               и переключателей только внешним видом и небольшими размерами, позволяющими им находится в JMenu.

                    Соответствие элементов управления и элементов меню:
                            Элементы управления	                                            Элементы меню
                       кнопка JButton	                                                элемент-меню JMenuItem
                       переключатель JRadioButton	                            элемент-переключатель JRadioButtonMenuItem
                       флажок JCheckBox	                                            элемент-флажок JCheckBoxMenuItem

                    В меню нет эквивалента выключателя JToggleButton. С его функциями справляются флажки и переключатели

               ПРИМЕР (создание простейшего системного меню)
                        -   F1_JMenuTest

                    В примере создается относительно простое меню, элементами которого являются фактически кнопки, собранные в список
               Списки элементов меню, или правильнее выпадающие меню (drop-down menus), реализованы в Swing классом JMenu.

                    Выпадающие меню JMenu создаются^
                        - createFileMenu()
                        - createViewMenu(),
                    в которых методом add() добавляются разнообразные элементы меню, в том числе элементы-флажки и элементы-переключатели

                    Выпадающие списки меню размещаются в строке меню класса JMenuBar, содержащей метод add() для добавления выпадающих меню JMenu
               Для размещения строки меню в интерфейсе окна вызывается метод setJMenuBar().

                    Элементы меню могут иметь названия, значки и мнемоники; они могут быть созданы на основе интерфейса AbstractAction


               ----------------------------------------- JMenuBar ------------------------------------------------------
                    Строка меню JMenuBar представляет обыкновенный контейнер, ничем не отличающийся от панели JPanel
               и обладающий теми же самыми свойствами.
                    JMenuBar может быть использована не только для работы с выпадающими меню.
                    В строку меню можно добавлять всевозможные компоненты, например надписи со значками или раскрывающиеся списки.
                    В качестве менеджера расположения JMenuBar использует BoxLayout с расположением компонентов по горизонтали

               ПРИМЕР (cоздания меню с клавиатурными комбинациями и мнемониками)
                        -   F2_JMenuBarTest

                    В примере создается простое выпадающее меню, после чего в JMenuBar помещается надпись с иконкой.
                        - для создания элементов пунктом меню "Файл" и "Редактирования" используется метод createMenuItems,
                          которому в качестве параметров передается многомерный массив строк с описанием пунктов меню
                          (этот метод создает элемент меню с "мнемоникой" и "акселератором")
                          При необходимости можно устанавливать в элемент меню изображение в виде иконки.
                        - createSubmenus() создает выпадающее меню с вложенными подпунктами

                    Размещение строки меню в интерфейсе окна осуществляется с помощью специального метода setJMenuBar().
                        - этот метод принадлежит корневой панели JRootPane, которая обеспечивает, чтобы строка меню занимала подобающее
                    ей положение на вершине окна, оставляя все оставшееся пространство в панели содержимого разработчику

                        В меню элементы можно группировать с использованием специального метода addSeparator().
                    Кроме того, разделители можно применять и вне меню в качестве разделительных линий, в том числе вертикальных.


               ----------------------------------------- JToolBar ------------------------------------------------------
                    Панели инструментов JToolBar предназначены для размещение в интерфейсе, как правило, набора кнопок особого вида:
                        - без надписей, но с подсказками и с небольшими изображениями.
                    Нажатием на такую кнопку инициируется выполнение команд приложения.
                    В панелях инструментов размещаются кнопки с наиболее востребованными пользователями командами.

                    JToolBar позволяет создавать любые панели инструментов, способные серьезно приукрасить и создать интуитивно понятный
               пользовательский интерфейс.

               Основные свойства панели инструментов JToolBar
                    -   orientation	    -   определение направления панели инструментов:
                                                - вертикальное или
                                                - горизонтальное (по умолчанию)
                                                Компоненты будут добавляться в заданном направлении
                                                Направление можно сменить и после создания панели инструментов

                    -   floatable	    -   	флаг перетаскивания панели инструментов (по умолчанию перетаскивание включено)
                                                    - если перетаскивание не нужно задается свойство  false

                    -   rollover	    -   	включение эффекта интерактивности — при наведении на компонент указателя мыши у компонента
                                                появляется специальная рамка или иной визуальный эффект (к примеру, особый значок)
                                                    -   по умолчанию эффект интерактивности отключен

                    -   borderPainted	-   	управление прорисовкой рамки панели инструментов.
                                                    -   наличие рамки зависит от внешнего вида и поведения
                                                    -   по умолчанию рамка отображается
                                                    Как правило, это специальная полоса, с помощью которой пользователь может перетаскивать
                                                панель инструментов

                    Панель инструментов JToolBar — это самый обыкновенный компонент  и его можно добавлять в любые панели с любым подходящим
               менеджером расположения
                    Таким образом, можно легко конструировать панели инструментов произвольной сложности, динамически добавлять и удалять их,
               составляя набор панелей из любого их количества

               ПРИМЕР (создания трех панелей инструментов, которые расположим их вместе так, чтобы две неперемещаемые панели располагались сверху,
                       а под ними будет размещаться перемещаемая JToolBar)
                                -   F3_JToolBarTest

                       Сами панели инструментов cостоят из:
                                -   настроенных команд Action,
                                -   кнопок JButton,
                                -   а также дополнительных компонентов.

                       В панели разместили раскрывающийся список JComboBox.
                            - следует обратить внимание на то, что после добавления во вторую панель инструментов раскрывающегося списка
                        был добавлен заполнитель (glue).

               Для добавления разделителя используется специальный метод addSeparator()
                    - размеры разделителя можно изменить
                      (для этого следует перегруженному методу addSeparator() передать объект Dimension, определяющий размеры разделителя)
               Используется разделитель в панели инструментов примерно так же, как в меню:
                    - для визуального отделения групп компонентов, выполняющих различные действия

                    Кнопки в панель инструментов можно добавлять в виде компонента JButton с использованием метода метода add(),
               а также как экземпляр команды Action с использованием специального перегруженного метода add().
                    Использование в качестве параметра команды Action во многих случаях очень удобно, поскольку позволяет совмещать в одном месте
               настройку внешнего вида элемента управления и описание действия, которое он выполняет.
                    Это особенно верно для панелей инструментов:
                        - в классе команды задается значок, текст подсказки и описывается действие, которое должна будет выполнить команда.
                        - после этого остается только добавить команду в панель инструментов.
                        - если же необходимо будет модифицировать команду, будь то внешний вид или действие, то это все скрыто в одном классе.

                    Следует обратить внимание на специальную полосу с левого края нижней перемещаемой панели инструментов.
               Это так называемые вешки перемещения :
                        - с их помощью можно перетаскивать (drag and drop) панель инструментов и "причаливать" (drag and dock) к разным края окна,
                    или же оставлять «плавающими».
                        - перетаскивать панели инструментов и причаливать их к краям окна можно, только если в нем используется
                    расположение BorderLayout.
                        - поэтому, если в вашем окне есть панели инструментов и вы хотите дать пользователю возможность их перетаскивать
                    к другим краям окна, применяйте менеджер расположения BorderLayout

                    Панели инструментов следует располагать так, чтобы их было удобно добавлять, удалять или перемещать.
                    Первые две панели инструментов были расположены в панели с горизонтальным блочным расположением с разделением их распоркой
               размером 5 пикселов


        11.4  JButton, JGroupButton, Action
               --------------------------------------- кнопки JButton --------------------------------------------------
                    Кнопки JButton кроме собственного внешнего вида не включают практически ничего уникального
               Поэтому всё, что верно для кнопок, будет верно и для остальных элементов управления.

                    Пример кода создания обычной кнопки :
                                JButton button = new JButton("Кнопка"):
                                    button.addActionListener(new ButtonAction());

                    Основное время работы с кнопками связано не столько с их созданием и настройкой, сколько с размещением в контейнере
               и написанием обработчиков событий


               -------- ИНТЕРФЕЙС КНОПОК
                    Внешний вид кнопок JButton можно легко изменить, не меняя менеджера внешнего вида и поведения.
               С интерфейсом кнопок можно делать практически все:
                        -   сопоставлять каждому действию пользователя своё изображение,
                        -   убирать рамку,
                        -   закрашивать в любой цвет,
                        -   перемещать содержимое по разным углам,
                        -   не рисовать фокус

               ПРИМЕР (создаем кнопки JButton разных форм и размеров)
                                -   G1_ButtonStylesTest

                        В примере создается небольшое окно с менеджером последовательного расположения FlowLayout.
                  В форме помещается несколько кнопок, для каждой из которых используется свой способ представления внешнего вида.

                        Первой в контейнер помещается самая обычная кнопка.
                        Затем следует кнопка, на которой вместо текста располагаются иконки на «все случаи жизни».
                  Для определения иконок применяются свойства:
                      - icon            -   установка «обычной» иконки
                      - rolloverlcon    -	получение эффекта «наведения мыши».
                                            Когда указатель мыши оказывается на кнопке, появляется эта иконка обычно в этом случае используется
                                            та же иконка, только к ней добавляется эффект объема или изменяется цвет части иконки
                      - pressedlcon     -	представление иконки, которая отображается при нажатии на кнопке.
                                            Иконка остается до тех пор, пока кнопка мыши не отпущена
                      - disabledlcon    -	если вы задаете иконку посредством данного свойства, то, когда кнопка будет отключена
                                            (метод setEnabled(false)), появится специальная иконка.
                                                если специальной иконки нет, а обычная иконка есть, то в качестве иконки для отключенной кнопки
                                            будет использована черно-белая копия обычной иконки

                      Если вывести кнопку с иконками на экран «как есть», она будет выглядеть не очень хорошо, поскольку у нее останутся
                  все свойственные обычной кнопке с текстом свойства — будет рисоваться рамка, при наличии фокуса появится контур,
                  а при нажатии она будет закрашиваться темным цветом.
                      Чтобы убрать эти эффекты, в примере и задействуются методы
                            -   setBorderPainted()
                            -   setFocusPainted()
                            -   setContentAreaFilled()

                      - setBorderPainted()      -   позволяет отключить прорисовку рамки.
                                                        то же самое можно сделать вызовом setBorder(null), но в этом случае нельзя вернуть кнопке
                                                    ее рамку обратно
                      - setFocusPainted()       -   отключает прорисовку специального контура, проявляющегося, если кнопка обладает фокусом ввода
                      - setContentAreaFilled()  -   дает возможность отключить закраску кнопки в нажатом состоянии.
                                                        с этими методами лучше быть осторожней, потому что пользователю с такой кнопкой работать
                                                    гораздо сложнее: будет непонятно, выбрана кнопка или нет, где она начинается и т. п.
                            Применять эти методы лучше только в тех приложениях, в которых весь интерфейс основан на разнообразных изображениях
                      (например, в играх)

                      - setBackground()         -   можно устанавливать цвет заполнения JButton.
                                                        цвет заполнения изменится только в том случае, если у кнопки включено свойство
                                                    непрозрачности (opaque). По умолчанию оно установлено.

                      Кнопки JButton также, как и надписи JLabel, позволяют определять интерфейс с использованием HTML,
                  что вместе с широчайшими возможностями по настройке расположения содержимого и по управлению всеми аспектами внешнего вида
                  кнопок дает неограниченную власть над видом приложения

                  ----- Настройки кнопок JButton -----
                  Ниже представлены параметры, позволяющие выполнить определенные настройки интерфейса кнопок JButton
                    -   margin                  -   управление размером полей, которые отделяют содержимое кнопки (текст и иконку) от ее границ
                    -   verticalAlignment       -   вертикальное и горизонтальное выравнивание всего содержимого кнопки (и значка, и текста)
                        horizontalAlignment	        относительно границ кнопки.
                                                        с их помощью это содержимое можно поместить в любой угол кнопки или в ее центр
                                                    (по умолчанию оно там и находится)
                    -   horizontalTextPosition  -   управление по горизонтали и вертикали положением текста кнопки относительно ее иконки,
                        verticalTextPosition	    если она есть, конечно
                    -   iconTextGap	            -   свойство позволяет изменить расстояние между иконкой и текстом


               -------- СОБЫТИЯ ЭЛЕМЕНТОВ УПРАВЛЕНИЯ  -  ActionEvent, ChangeEvent, ItemEvent
                    Унаследованные от класса AbstractButton элементы управления, в том числе и кнопки JButton, могут посылать сообщения
               о трех типах событий (за исключением стандартных событий, общих для всех компонентов Swing), а именно:

                    -   ActionEvent     -   слушатель ActionListener     -      событие при нажатии и отпускании кнопки

                    -   ChangeEvent     -   слушатель ChangeListener     -      с помощью данного события модель кнопок ButtonModel
                                                                                взаимодействует со своим UI-представителем
                                                                                    Модель при изменении хранящегося в ней состояния кнопки
                                                                                (это может быть смена включенного состояния на выключенное,
                                                                                обычного на нажатое и т. п.) запускает событие ChangeEvent.
                                                                                    UI-представитель обрабатывает это событие и соответствующим
                                                                                образом перерисовывает кнопку

                    -   ItemEvent       -   слушатель ItemListener       -      событие о смене состояния возникает в компонентах,
                                                                                которые имеют несколько равноценных состояний
                                                                                (например, флажки и переключатели)

                    В примере после создания первой кнопки к ней подключаются слушатели событий.
                    Для событий ActionEvent и ChangeEvent слушатели помещаются в отдельные внутренние классы, а слушатель события ItemEvent
               создается прямо на месте, как анонимный внутренний класс.
                    При возникновении события информация об инициаторе выводится в консоль приложения
                    При щелчке на кнопке слушатель события определяет имя нажатой кнопки, используя метод getActionCommand() класса ActionEvent.
                    Этот метод применяется для того, чтобы при обработке событий от нескольких кнопок в одном слушателе можно было их отличить.
                    Событие ItemEvent не возникает вовсе, поскольку оно «работает» только с флажками, переключателями и другими компонентами,
               имеющими состояние, а кнопки его просто игнорируют

               ПРИМЕР (использования Action при создании JButton)
                            -   G2_AbstractActionTest

               Cоздаются две кнопки, которые выполняют одно и то же действие, и обладают одним и тем же набором параметров
                   - чтобы не дублировать код для настройки этих кнопок, создается один экземпляр команды SimpleAction, который передается кнопкам
                   - SimpleAction расширяет абстрактный класс AbstractAction, имеющий поддержку слушателей PropertyChangeListener,
                 которые оповещаются об изменениях в параметрах команды.
                   - кнопки выступают в роли таких слушателей, что и позволяет им быть в курсе всех изменений и вовремя отображать их на экране
                   - все сводится к настройке параметров команды (обычно это производится в конструкторе) и определению метода actionPerformed(),
                 отвечающего за обработку событий

                   Параметры команды хранятся в виде пар «ключ-значение», где ключ — одна из строк, определенных в интерфейсе Action.
                        - эта строка показывает, какой именно параметр команды хранится в паре
                        - для того чтобы изменить параметр, используется метод putValue()
                        - параметры интерфейса Action
                                - NAME                  -   определение надписи, которая будет выведена на кнопке или в меню
                                - SHORT_DESCRIPTION     -   определение всплывающей подсказки
                                - MNEMONIC_KEY          -   определение мнемоники
                                - остальной список ключей можно в документации Java

               В методе actionPerformed() определяется источник, вызвавший событие кнопки JButton
                   - если это кнопкам button1, то меняется ее наименование и она блокируется


               -------- МНЕМОНИКИ
                    Разработчики наделили библиотеку поддержкой мнемоник для всех элементов управления.
                    Мнемоники позволяют получить доступ к компоненту нажатием специальной клавиши (обычно Alt) вместе с клавишей символа,
               идентифицирующего этот компонент

                    Для обеспечения доступа пользователя к визуальному компоненту с помощью клавиатуры следует использовать следующие
               методы класса AbstractButton :
                    -   setMnemonic()               -    определение мнемоники, то есть определение клавиши символа в сочетании с управляющей
                                                         клавишей (Alt) будет вызывать нажатие кнопки.
                                                            Можно просто указать символ (в одинарных кавычках, регистр не учитывается),
                                                         а можно использовать константы из класса Java.awt.event.KeyEvent.
                    -   setDisplayedMnemonicIndex() -    после жалоб разработчиков на невозможность управлять тем, какой из символов надписи кнопки
                                                         будет подчеркиваться, то есть символизировать наличие мнемоники, если в надписи есть
                                                         несколько одинаковых символов

                    Пример определения мнемоники кнопки JButton :
                                        JButton button = new JButton("Файл (F)");
                                                button.setMnemonic('F');


               ------------- элементы управления кнопки JToggleButton, ButtonGroup, JRadioButton, JCheckBox ------------
                    В приложениях, кроме кнопок, используются другие элементы управления, для которых характерно наличие двух устойчивых состояний.
               К ним относятся:
                        - флажки,
                        - переключатели и
                        - выключатели.
                    Единственное отличие их от JButton состоит в том, что они могут находиться в одном из двух состояний.
                    При смене состояния эти компоненты генерируют событие ItemEvent, которое кнопки игнорируют.

                    Поддержка двух состояний встроена в класс выключателя JToggleButton, от которого, в свою очередь, унаследованы классы
               флажков и переключателей

               --------- Выключатель JToggleButton
                    Чаще всего используется в панелях инструментов, где он играет роль флажков.
                        - фактически, по виду это та же самая кнопка, только ее можно нажать, и она остается в этом состоянии
                        - можно использовать JToggleButton и в обычном интерфейсе, когда нужно сделать выбор из двух альтернатив

               --------- Группы элементов управления ButtonGroup
                    Класс ButtonGroup позволяет связать несколько элементов управления в логическую группу, в которой выбранным может быть
               только один из них
                    При выборе пользователем другого элемента управления класс ButtonGroup позаботится о том, чтобы выбранный прежде элемент
               вернулся в исходное состояние

               --------- Переключатели JRadioButton
                    Переключатель JRadioButton унаследован от выключателя JToggleButton и отличается от него только внешним видом.
               JRadioButton используют, как правило, при объединении нескольких переключателей в группу и реализации выбора «один из многих».
               По одиночке в интерфейсе их практически не используют; обычно эту роль исполняют флажки.

               --------- Флажки JCheckBox
                    Флажки в библиотеке Swing реализуются классом JCheckBox.
                    Они, также как и переключатели, отличаются от выключателей только внешним видом.
                    Флажки используются там, где нужно предоставить пользователю возможность что-то включить или выключить.
                    Они также могут группироваться.
                    Но, в отличие от JRadioButton, никогда не реализуют выбор «один из нескольких», а всегда позволяют выбрать несколько
               равноценных вариантов.

               ПРИМЕР (который включает все перечисленные элементы управления)
                            -   G3_ButtonsTest

                    Изначально в примере кнопка JToggleButton отпущена, панель panelRadio «открыта», в панели размещены кнопки JRadioButton
               Панель panelCheck «скрыта»
                    После нажатия на кнопку JToggleButton, панель panelCheck «открыта», в панели размещены кнопки JCheckBox
               Панель panelRadio «скрыта»

                    В примере обработка события «изменения состояния кнопки» JToggleButton выполняется в методе itemStateChanged
               слушателя ItemListener.
                    В зависимости от состояния нажатия кнопки изменяется название кнопки и «окрывается/скрывается» одна из панелей


        11.4  JTextField, JTextArea, JTextPane

               ------------- элементы управления кнопки JToggleButton, ButtonGroup, JRadioButton, JCheckBox ------------













Корневая панель JRootPane
Многослойная панель JLayeredPane
Панель содержимого ContentPane
Прозрачная панель JOptionPane
Строка меню JMenuBar

Корневая панель JRootPane
Каждый раз, как только создается контейнер высшего уровня, будь то обычное окно, диалоговое окно или апплет, в конструкторе этого контейнера создается корневая панель JRootPane. Контейнеры высшего уровня Swing следят за тем, чтобы другие компоненты не смогли "пробраться" за пределы JRootPane.

Корневая палель JRootPane добавляет в контейнеры свойство "глубины", обеспечивая возможность не только размещать компоненты один над другим, но и при необходимости менять их местами, увеличивать или уменьшать глубину расположения компонентов. Такая возможность необходима при создании многодокументного приложения Swing, у которого окна представляют легковесные компоненты, располагающиеся друг над другом, а также выпадающими (контекстными) меню и всплывающими подсказками.

На следующем рисунке наглядно представлена структура корневой панели JRootPane.

Корневая панель JRootPane
Корневая панель JRootPane представляет собой контейнер, унаследованный от базового класса Swing JComponent. В этом контейнере за расположение компонентов отвечает специальный менеджер расположения, реализованный во внутреннем классе RootPaneLayout. Этот менеджер расположения отвечает за то, чтобы все составные части корневой панели размещались так, как им следует: многослойная панель занимает все пространство окна; в ее слое FRAME_CONTENT_LAYER располагаются строка меню и панель содержимого, а над всем этим располагется прозрачная панель.

Все составляющие корневой панели JRootPane можно получить или изменить. Для этого у нее есть набор методов get/set. Программным способом JRootPane можно получить с использованием метода getRootPane().

Кроме контейнеров высшего уровня корневая панель применяется во внутренних окнах JInternalFrame, создаваемых в многодокументных приложениях и располагающихся на "рабочем столе" JDesktopPane. Это позволяет забыть про то, что данные окна представляют собой обычные легковесные компоненты, и работать с ними как с настоящими контейнерами высшего уровня.

Многослойная панель JLayeredPane
В основании корневой панели (контейнера) лежит так называемая многослойная панель JLayeredPane, занимающая все доступное пространство контейнера. Именно в этой панели располагаются все остальные части корневой панели, в том числе и все компоненты пользовательского интерфейса.

JLayeredPane используется для добавления в контейнер свойства глубины (depth). To есть, многослойная панель позволяет организовать в контейнере третье измерение, вдоль которого располагаются слои (layers) компонента. В обычном контейнере расположение компонента определяется прямоугольником, который показывает, какую часть контейнера занимает компонент. При добавлении компонента в многослойную панель необходимо указать не только прямоугольник, занимаемый компонентом, но и слой, в котором он будет располагаться. Слой в многослойной панели определяется целым числом. Чем больше определяющее слой число, тем выше слой находится.

Первый добавленный в контейнер компонент оказывается выше компонентов, добавленных позже. Чаще всего разработчик не имеет дело с позициями компонентов. При добавлении компонентов их положение меняются автоматически. Тем не менее многослойная панель позволяет менять позиции компонентов динамически, уже после их добавления в контейнер.

Возможности многослойной панели широко используются некоторыми компонентами Swing. Особенно они важны для многодокументных приложений, всплывающих подсказок и меню. Многодокументные Swing приложения задействуют специальный контейнер JDesktopPane («рабочий стол»), унаследованный от JLayeredPane, в котором располагаются внутренние окна Swing. Самые важные функции многодокументного приложения — расположение «активного» окна над другими, сворачивание окон, их перетаскивание — обеспечиваются механизмами многослойной панели. Основное преимущество от использования многослойной панели для всплывающих подсказок и меню — это ускорение их работы. Вместо создания для каждой подсказки или меню нового тяжеловесного окна, располагающегося над компонентом, в котором возник запрос на вывод подсказки или меню, Swing создает быстрый легковесный компонент. Этот компонент размещается в достаточно высоком слое многослойной панели выше в стопке всех остальных компонентов и используется для вывода подсказки или меню.

Многослойная панель позволяет организовать неограниченное количество слоев. Структура JLayeredPane включает несколько стандартных слоев, которые и используются всеми компонентами Swing, что позволяет обеспечить правильную работу всех механизмов многослойной панели. Стандартные слои JLayeredPane представлены на следующем рисунке.

Стандартные слои Swing
Default

Слой Default используется для размещения всех обычных компонентов, которые добавляются в контейнер. В этом слое располагаются внутренние окна многодокументных приложений.

Palette

Слой Palette предназначен для размещения окон с набором инструментов, которые обычно перекрывают остальные элементы интерфейса. Создавать такие окна позволяет панель JDesktopPane, которая размещает их в этом слое.

Modal

Слой Modal планировался для размещения легковесных модальных диалоговых окон. Однако такие диалоговые окна пока не реализованы, так что этот слой в Swing в настоящее время не используется.

Popup

Наиболее часто используемый слой, служащий для размещения всплывающих меню и подсказок.

Drag

Самый верхний слой. Предназначен для операций перетаскивания (drag and drop), которые должны быть хорошо видны в интерфейсе программы.

Небольшой пример JLayeredPane с многослойной панелью показывает, как добавлять компоненты в различные слои и как слои располагаются друг над другом :

import javax.swing.*;
import java.awt.*;

// класс рисования двух типов фигур с текстом
class Figure extends JComponent
{
    private static final long serialVersionUID = 1L;
    private Color color;
    private int type;
    private String text;
    // параметры: цвет и тип фигуры
    Figure(Color color, int type, String text) {
        this.color = color;
        this.type = type;
        this.text = text;
        setOpaque(false);
    }
    public void paintComponent(Graphics g) {
        // прорисовка фигуры
        g.setColor(color);
        switch (type) {
        case 0: g.fillOval(0, 0, 90, 90); break;
        case 1: g.fillRect(0, 0, 130, 80); break;
        }
        g.setColor(Color.yellow);
        g.drawString(text, 10, 35);
    }
}
public class JLayeredPaneTest extends JFrame
{
    private static final long serialVersionUID = 1L;

    public JLayeredPaneTest()
    {
        // создание окна
        super("Example LayeredTest");
        // выход при закрытии окна
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        // определение многослойной панели
        JLayeredPane lp = getLayeredPane();
        // создание трех фигур
        Figure figure1 = new Figure(Color.red , 0, "Figure popup");
        Figure figure2 = new Figure(Color.blue, 0, "Figure 1");
        Figure figure3 = new Figure(Color.cyan, 1, "Figure 2");
        // определение местоположения фигур в окне
        figure1.setBounds(10, 40, 120, 120);
        figure2.setBounds(60, 120, 160, 180);
        figure3.setBounds(90, 55, 250, 180);
        // добавление фигур в различные слои
        lp.add(figure1, JLayeredPane.POPUP_LAYER  );
        lp.add(figure2, JLayeredPane.PALETTE_LAYER);
        lp.add(figure3, JLayeredPane.PALETTE_LAYER);
        // смена позиции одной из фигур
        lp.setPosition(figure3, 0);
        // определение размера и открытие окна
        setSize(280, 250);
        setVisible(true);
    }
    public static void main(String[] args)
    {
        JFrame.setDefaultLookAndFeelDecorated(true);
        new JLayeredPaneTest();
    }
}
В примере создается небольшое окно JFrame и в многослойную панель добавляется несколько компонентов Figure. Чтобы получить многослойную панель в любом контейнере Swing высшего уровня, достаточно вызвать метод getLayeredPane().

Вспомогательный класс Figure наследует свойства базового класса JComponent и позволяет различными цветами рисовать фигуры двух типов (круги и прямоугольники). Параметры для прорисовки фигур задаются в конструкторе класса.

При определении интерфейса создаются три фигуры разного цвета (два круга и прямоугольник). Круг размещается в слое POPUP_LAYER, а прямоугольники — в слое PALETTE_LAYER. При размещении компонентов указываются их абсолютные экранные координаты, потому что в многослойной панели обычные менеджеры расположения не работают.
В завершении позиция одного из прямоугольников меняется так, чтобы он был первым в слое, хотя изначально добавлялся вторым. Запустив приложение, вы увидите, что многослойная панель работает и аккуратно располагает компоненты согласно их слоям и позициям.

Пример Swing с использованием JLayeredPane
В обычных приложениях многослойная панель редко используется напрямую, в них она выполняет свои функции незаметно. Тем не менее, иногда она помогает создать удивительные эффекты и необычные интерфейсы, позволяя, например, разместить поверх обычных компонентов анимацию или видео, не требуя для этого от разработчика нечеловеческих усилий и ухищрений.

Панель содержимого ContentPane
Панель содержимого ContentPane - это следующая часть корневой панели, которая используется для размещения компонентов пользовательского интерфейса программы. ContentPane занимает большую часть пространства многослойной панели (за исключением места, занимаемого строкой меню). Чтобы панель содержимого не закрывала добавляемые впоследствии в окно компоненты, многослойная панель размещает ее в специальном очень низком слое с названием FRAME_CONTENT_LAYER, с номером -30000.

Обратиться к панели содержимого можно методом getContentPane() класса JFrame. С помощью метода add(Component component) можно добавить на нее любой элемент управления. Заменить ContentPane любой другой панелью типа JPanel можно методом setContentPane()

Пример добавления кнопки в панель содержимого :

JButton newButton = new JButton();
getContentPane().add(newButton);Пример Swing с использованием JLayeredPane
В результате получим окно с кнопкой. Кнопка занимает всю доступную площадь окна. Такой эффект полезен не во всех программах, поэтому необходимо использовать различные способы расположения элементов на панели.

Панель содержимого можно полностью заменить. Рассмотрим следующий Swing пример использования панели содержимого ContentPane.

import javax.swing.*;
public class ContentPaneReplace extends JFrame
{
    private static final long serialVersionUID = 1L;

    public ContentPaneReplace()
    {
        super("B_ReadMe.B7_Reflection.Test ContentPane");
        setDefaultCloseOperation(EXIT_ON_CLOSE);

        // Создание панели с двумя кнопками
        JPanel contents = new JPanel();
        contents.add(new JButton("Семья"));
        contents.add(new JButton("Школа"));
        // Замена панели содержимого
        setContentPane(contents);

        // Определение размера окна
        setSize(200, 100);
        // Открытие окна
        setVisible(true);
}
    public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);
        new ContentPaneAdd();
    }
}
В примере создается небольшое окно и панель с двумя кнопками, которая затем методом setContentPane() заменяет панель содержимого окна. Таким образом была использована замена вместо более простого добавления - вызова метода add(). Интерфейс окна представлен на следующем скриншоте.

Пример Swing с заменой панели содержимого ContentPane
Панель содержимого ContentPane сама собой не представляет ничего особенного. Необходимо лишь помнить, что компоненты добавляются именно в нее.

Прозрачная панель JOptionPane
Прозрачная панель JOptionPane размещается корневой панелью выше всех элементов многослойной панели. За размещением JOptionPane следит корневая панель, которая размещает прозрачную панель выше многослойной панели, причем так, чтобы она полностью закрывала всю область окна, включая и область, занятую строкой меню.

JOptionPane используется в приложениях достаточно редко, поэтому по умолчанию корневая панель делает ее невидимой, что позволяет уменьшить нагрузку на систему рисования. Следует иметь в виду, что если вы делаете прозрачную панель видимой, нужно быть уверенным в том, что она прозрачна (ее свойство opaque равно false), поскольку в противном случае она закроет все остальные элементы корневой панели, и остальной интерфейс будет невидим.

В каких случаях можно использовать прозрачную панель JOptionPane? С ее помощью можно определять функции приложения, для реализации которых «с нуля» понадобились бы серьезные усилия. Прозрачную панель можно приспособить под автоматизированное тестирование пользовательского интерфейса. Синтезируемые в ней события позволяют отслеживать промежуточные отладочные результаты. Иногда такой подход гораздо эффективнее ручного тестирования.

Прозрачная панель JOptionPane может быть использована для эффектной анимации, «плавающей» поверх всех компонентов, включая строку меню, или для перехвата событий, если некоторые из них необходимо обрабатывать перед отправкой в основную часть пользовательского интерфейса.

Пример использования прозрачной панели Swing JOptionPane :
// Использование прозрачной панели JOptionPane
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;


import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.UIManager;

public class JOptionPaneTest extends JFrame
{
    private static final long serialVersionUID = 1L;

    public static final Font FONT = new Font("Verdana", Font.PLAIN, 11);

    public static void createGUI()
    {
        JFrame frame = new JFrame("B_ReadMe.B7_Reflection.Test JOptionPane");

        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

        frame.addWindowListener(new WindowListener() {

            public void windowActivated(WindowEvent event) {}

            public void windowClosed(WindowEvent event) {}


            public void windowDeactivated(WindowEvent event) {}

            public void windowDeiconified(WindowEvent event) {}

            public void windowIconified(WindowEvent event) {}

            public void windowOpened(WindowEvent event) {}

            public void windowClosing(WindowEvent event)
            {
                Object[] options = { "Да", "Нет!" };
                int rc = JOptionPane.showOptionDialog(
                                event.getWindow(), "Закрыть окно?",
                                "Подтверждение", JOptionPane.YES_NO_OPTION,
                                                 JOptionPane.QUESTION_MESSAGE,
                                                 null, options, options[0]);
                if (rc == 0) {
                    event.getWindow().setVisible(false);
                    System.exit(0);
                }
            }
         });
        JLabel label = new JLabel("Использование прозрачной панели при закрытии окна");
        frame.getContentPane().add(label);

        frame.setPreferredSize(new Dimension(350, 80));
        frame.pack();
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                UIManager.put("Button.font", FONT);
                UIManager.put("Label.font", FONT);
                JFrame.setDefaultLookAndFeelDecorated(true);
                JDialog.setDefaultLookAndFeelDecorated(true);
                createGUI();
            }
        });
    }
}
Если методу setDefaultCloseOperation передать константу JFrame.EXIT_ON_CLOSE, то при закрытии окна приложение будет прекращать работу. В примере этому методу передается константа JFrame.DO_NOTHING_ON_CLOSE, чтобы при закрытии окна ничего не происходило. Выход из приложения в примере осуществляется из JFrame слушателя WindowListener в методе windowClosing. При закрытии окна вызывается метод windowClosing с параметром WindowEvent event, который в прозрачной панели Swing JOptionPane открывает диалоговое окно подтверждения.

На следующем скриншоте представлены два окна приложения. Верхнее главное окно. При закрытии данного окна открывается нижнее диалоговое окно подтверждения намерения.

Пример Swing с прозрачной панелью JOptionPane
Строка меню JMenuBar
Одной из важных особенностей использования корневой панели JRootPane в Swing, является необходимость размещения в окне строки меню JMenuBar. Серьезное приложение нельзя построить без какого-либо меню для получения доступа к функциям программы. Библиотека Swing предоставляет прекрасные возможности для создания удобных меню JMenuBar, которые также являются легковесными компонентами.

Строка меню JMenuBar размещается в многослойной панели в специальном слое FRAME_CONTENT_LAYER и занимает небольшое пространство в верхней части окна. По размерам в длину строка меню равна размеру окна. Ширина строки меню зависит от содержащихся в ней компонентов.

Корневая панель следит, чтобы панель содержимого и строка меню JMenuBar не перекрывались. Если строка меню не требуется, то корневая панель использует все пространство для размещения панели содержимого.







