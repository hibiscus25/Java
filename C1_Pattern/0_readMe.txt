Creation patterns(Порождающие шаблоны):
    - Factory
    - AbstractFactory
    - FactoryMethod
    - Singleton
    - Builder
    - Prototype
    - ObjectPool

    -------------- Factory ---------------------------------------------------------------------------------------------
        Цель:                   создание интерфейса, который создает объект.
                                    При этом выбор того, экземпляр какого класса создавать остается за классами,
                                которые имплементируют данный интерфейс

        Используется:           для делегирования создания экземпляров, другому классу

        Пример использования:   - заранее  неизвестно, экземпляры, какого класса нужно будет создавать
                                - класс спроектирован таким образом, что создаваемые им объекты имеют свойства определенного класса

    -------------- AbstractFactory -------------------------------------------------------------------------------------
        Цель:                   создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов,
                                без жесткой привязке к конкретным методам

        Используется:           для создания множеств взаимосвязанных объектов

        Пример использования:   - система не должна зависеть от метода создания, компоновки и представления входящих в нее объектов;
                                - входящие взаимосвязанные объекты должны использоваться вместе;
                                - система должна конфигурироваться одним из множества объектов, из которых она состоит;
                                - нам необходимо представить  множество объектов, раскрывая только их интерфейсы, но не реализацию

    -------------- Singleton -------------------------------------------------------------------------------------------
        Цель:                   гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена
                                глобальная точка доступа

        Используется:           для создания единственного экземпляра определенного класса

        Пример использования:   - необходим только один экземпляр конкретного класса, который доступен для всех клиентов
                                - единственный экземпляр должен наследоваться путем порождения подклассов,
                                  при этом, клиенты имеют возможность работать с классом-наследником без модификации своего кода

    -------------- Builder ---------------------------------------------------------------------------------------------
        Цель:                   отделить конструирование сложного объекта от его представления таким образом, чтобы в результате
                                одного и того же конструирования мы могли получить разные представления

        Используется:           для создания различных объектов из одного набора данных

        Пример использования:   - порядок создания сложного объекта не должен зависеть от того, из каких частей состоит объект и того,
                                  как эти объекты взаимосвязаны
                                - процесс конструирования объекта должен предоставлять  различные представления объекта,
                                  который мы конструируем

    -------------- Prototype -------------------------------------------------------------------------------------------
        Цель:                   определить вид создаваемых объектов с помощью экземпляра - прототипа и создавать новые объекты,
                                копируя этот прототип

        Используется:           для создания копий заданного объекта

        Пример использования:   - классы, экземпляры которых необходимо создать определяются во время выполнения программы
                                - для избежания построения иерархии классов, фабрик или параллельных иерархий классов
                                - экземпляры класса могут находиться в одном из немногих возможных состояний

//======================================================================================================================

Structural patterns(Стуктурные шаблоны):
    - Adapter
    - Bridge
    - Composite
    - Decorator
    - Facade
    - Flyweight
    - Proxy

    -------------- Adapter ---------------------------------------------------------------------------------------------
        Цель:                   преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту

        Используется:           для обеспечения совместной работы классов, интерфейсы которых не совместимы

        Пример использования:   - интерфейс класса, который мы хотим использовать не соответствует нашим потребностям
                                - необходим класс, который должен взаимодействовать с классами, которые ему неизвестны
                                  или не связаны с ним
                                - необходимо использовать несколько существующих подклассов, но нецелесообразно использовать
                                  методы этих классов создавая их новые подклассы

    -------------- Bridge ----------------------------------------------------------------------------------------------
        Цель:                   отделить абстракцию от ее реализации таким образом, чтобы мы могли изменять независимо
                                друг от друга и то и другое

        Используется:           для получения преимуществ наследования без потери гибкости

        Пример использования:   - предотвращения жесткой привязки абстракции к реализации
                                  (например, реализацию необходимо выбрать во время выполнения программы)
                                - в будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию
                                - если изменения в реализации не должны отражаться на клиентах абстракции
                                - для разделения одной реализации между несколькими объектами и не показывать это клиенту

    -------------- Composite -------------------------------------------------------------------------------------------
        Цель:                   скомпонировать  объекты в структуры по типу "дерева", позволяя клиентам единообразно
                                трактовать отдельные и составные объекты

        Используется:           для групировки мелких компонентов в более крупные, которые в свою очередь, могут стать
                                основой для еще более крупных структур

        Пример использования:   - для представления иерарахии "часть - целое"
                                - мы хотим,  чтобы клиенты одним способом трактовали как отдельные, так и составные объекты

    -------------- Decorator -------------------------------------------------------------------------------------------
        Цель:                   динамическое добавление новых обязанностей объекту

        Используется:           используется в качестве альтернативы порождению  подклассов для расширения
                                функциональности

        Пример использования:   - динамическое и понятное клиентам добавление обязанностей объектам
                                - реализация обязанностей, которые могут быть сняты с объекта
                                - расширение класса путем порождения подклассов невозможно по каким - либо причинам

    -------------- Facade ----------------------------------------------------------------------------------------------
        Цель:                   предоставить унифицированный интерфейс вместо нескольких  интерфейсов подсистемы

        Используется:           для определения интерфейса высокого уровня, который упрощает использование подсистемы

        Пример использования:   - изолирование клиентов от компонентов подсистемы, упрощая работу с ней
                                - необходимость ослабления связанности подсистемы с клиентами

    -------------- Flyweight -------------------------------------------------------------------------------------------
        Цель:                   поддержка множества мелких объектов

        Используется:           использует разделение для того, чтобы поддерживать много мелких объектов

        Пример использования:   - когда используется большое число объектов
                                      - большую часть состояния объектов можно вынести наружу
                                      - приложение не зависит от идентичности объекта

    -------------- Proxy -----------------------------------------------------------------------------------------------
        Цель:                   для замещения другого объекта и контроля доступа к нему

        Используется:           для обеспечения контроля доступа к определенному объекту

        Пример использования:   - когда есть необходимость ссылаться на объект способом отличным от обычного указателя
                                    * удаленное замещение    -   локальный представитель вместо объекта в другом
                                                                 адресном пространстве
                                    * виртуальное замещение  -   создание "тяжелых объектов" при необходимости
                                    * защищенное замещение   -   контроль доступа к указанному объекту
                                    * умная ссылка           -   замена обычного указателя
                                                                 (подсчет числа ссылок, установка блокировки и тд)

//======================================================================================================================

Behavior patterns (шаблоны поведения):
    - Chain of Responsibility
    - Command
    - Interpreter
    - Iterator
    - Mediator
    - Momento
    - Observable
    - State
    - Strategy
    - Template method
    - Visitor

    -------------- Chain of Responsibility -----------------------------------------------------------------------------
        Цель:                   cвязывание объектов-получателей в цепочку и передача запроса по ней

        Используется:           помогает избежать привязки отправителя запроса к его получателю, что дает возможность
                                обработать данный запрос нескольким объектам

        Пример использования:   - ослабление привязанности (объект не должен знать, кто именно обработает его запрос)
                                - дополнительная гибкость при распределении обязанностей между объектами

    -------------- Command ---------------------------------------------------------------------------------------------
        Цель:                   инкапсулирование запроса в объект

        Используется:           чтобы задать параметры клиентов для обработки определенных запросов,
                                создание очереди из этих запросов или их контроля и поддержки отмены операций

        Пример использования:   - параметризация объектов выполняемым действием
                                - определять запрос, ставить его в очередь или выполнять его в разное время

    -------------- Interpreter -----------------------------------------------------------------------------------------
        Цель:                   определение представления грамматики объекта

        Используется:           используется для определения представления грамматики заданного языка
                                и интерпретации его предложений

        Пример использования:   - упрощение иерархии классов с помощью интерпретирования

    -------------- Iterator --------------------------------------------------------------------------------------------
        Цель:                   получение последовательного доступа ко всем элементам составного объекта

        Используется:           для получения последовательного доступа ко всем элементам составного объекта,
                                скрывая его внутреннее представление

        Пример использования:   - различные виды обхода составного объекта
                                - упрощенный доступ к составному объекту

    -------------- Mediator --------------------------------------------------------------------------------------------
        Цель:                   инкапсуляция способа взаимодействия множества объектов

        Используется:           для определения объекта, который инкапсулирует способ взаимодействия множества объектов
                                и обеспечения слабой связи между этими объектами

        Пример использования:   - связи между объектами сложны и четко определены
                                - нельзя повторно использовать объект, так как он обменивается информацией с другими объектами
                                - поведение, распределенное между несколькими классами должно легко настраиваться
                                  без создания подклассов

    -------------- Momento ---------------------------------------------------------------------------------------------
        Цель:                   сохранить внутреннее состояние объекта за его пределы

        Используется:           фиксирование внутреннего состояния объекта за его пределами не нарушая инкапсуляцию
                                и восстановление объекта в случае необходимости

        Пример использования:   - необходимо сохранить текущее состояние объекта или его части и восстановление в будущем,
                                  но прямое получение состояния раскрывает детали реализации и нарушает инкапсуляцию объекта

    -------------- Observable ------------------------------------------------------------------------------------------
        Цель:                   определение зависимости "один ко многим" между объектами

        Используется:           определения зависимости "один ко многим" между объектами таким образом,
                                что при изменении состояния одного объекта все зависящие от него объекты были
                                уведомлены об этом и обновились

        Пример использования:   - когда у модели имеются два аспекта, один из которых зависит от другого.
                                  Инкапсулирование этих аспектов в разные классы позволяют использовать их независимо друг от друга
                                - когда один объект должен оповещать другие и не делать предложений об этих объектах
                                - ослабление связи между объектами

    -------------- State -----------------------------------------------------------------------------------------------
        Цель:                   управление поведением объекта в зависимости от состояния

        Используется:           позволяет нам управлять поведением объекта в зависимости от внутреннего состояния объекта

        Пример использования:   - поведение объекта зависит от его состояния и изменяется во время выполнения
                                - когда встречается большое количество условных операторов, когда выбор ветви зависит
                                  от состояния объекта

    -------------- Strategy --------------------------------------------------------------------------------------------
        Цель:                   взаимозаменяемость семейства классов

        Используется:           определения семейства классов, инкапсулирование каждого из них и организация их взаимозаменяемости

        Пример использования:   - есть несколько родственных классов, которые отличаются поведением
                                - необходимо иметь несколько вариантов поведения
                                - в классе есть данные, о которых не должен знать клиент
                                - с помощью условных операторов в классе определено большое количество возможных поведений

    -------------- Template method -------------------------------------------------------------------------------------
        Цель:                   определение основы класса и создание возможности подклассам переопределять его части

        Используется:           определяет основу класса и позволяет подклассам переопределять некоторые его части
                                не изменяя его структуру

        Пример использования:   - однократное использование различных частей класса, оставляя реализацюи изменяющегося
                                  поведения на усмотрение подклассов
                                - вычленение и локализация общего для всех подклассов поведения в родительском
                                - управление расширениями подклассов

    -------------- Visitor ---------------------------------------------------------------------------------------------
        Цель:                   описание действий, которые выполняются с каждым объектом в некоторой структуре

        Используется:           описание операций, которые выполняются с каждым объектом из некоторой структуры
                                Позволяет определить новую операцию без изменения классов этих объектов

        Пример использования:   - в структуре присутствует объекты многих классов с различными интерфейсами
                                  и нам необходимо выполнить над ними операции, которые зависят от конкретных классов
                                - необходимо выполнить  не связанные между собой операции над объектами,
                                  которые входят в состав структуры и мы не хотим добавлять эти операции в классы
                                - классы, которые устанавливают структуру объектов редко изменяются, но часто добавляются
                                  новые операциии над этой структурой

