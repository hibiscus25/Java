
    ------------------------------------------------- XML --------------------------------------------------------------
            XML (eXtensible Markup Language) - расширяемый язык разметки описания документов, напоминающий язык разметки
    гипертекста HTML, но гораздо более универсальный.
            HTML и XML похожи синтаксисом, так как у них общий родитель – SGML.
                HTML    - набор стандартных тэгов, которые должен понимать любой веб - браузер
                XML     - дает пользователю возможность определять свои собственные тэги.
            Как результат, в формате XML можно представить документ любой структуры, содержащий информацию практически
    любой природы, но разработка программного обеспечения для чтения таких документов представляет собой самостоятельную
    задачу

    Пример XML:
            <?xml version="1.0" encoding="UTF-8"?>
            <company>
                <name>IT-Heaven</name>
                <offices>
                    <office floor="1" room="1">
                        <employees>
                            <!-- Иван недавно уволился, только неделю отработать должен-->
                            <employee>
                                <name>Maksim</name>
                                <job>Middle Software Developer</job>
                            </employee>
                            <!-- Иван недавно уволился, только неделю отработать должен-->
                            <employee>
                                <name>Ivan</name>
                                <job>Junior Software Developer</job>
                            </employee>
                        </employees>
                    </office>
                    <office floor="1" room="2">
                        <employees>
                            <employee>
                                <name>Herald</name>
                                <job>Middle Software Developer</job>
                            </employee>
                            <employee>
                                <name>Adam</name>
                                <job>Middle Software Developer</job>
                            </employee>
                        </employees>
                    </office>
                </offices>
            </company>

        -   Декларация      -   <?xml version="1.0" encoding="UTF-8"?>
                    - она обязательная и нужна для идентификации документа как XML
                    - в декларации есть три псевдо-атрибуты (специальные предопределенные атрибуты):
                            - version (по стандарту 1.0)
                            - encoding (кодировка)
                            - standalone (автономность)
                                    - no - по умолчанию
                                    - если yes и к документу подключаются внешние схемы, то будет ошибка
        -   Корень дерева   –   <company>
                    - он же – корневой (рут) элемент, от которого идут все остальные элементы
                    - в каждом XML файле может быть только один рут элемент
                    - он должен объявляться после декларации xml (первая строчка XML) и вмещать в себе все другие элементы
        -   Элементы        –   <name>, <offices> и др
                    – сущности, которые хранят данные с помощью других элементов и атрибутов.
        -   Атрибуты        –   floor="1" room="2"
                    - дополнительная информация об элементе, которая указывается при добавлении элемента
        -   Комментарий     -   <!-- Иван недавно уволился, только неделю отработать должен-->
                    - текст, который будет пропускаться при парсинге файла

    Структуру можно описывать как хочется
            <?xml version="1.0" encoding="UTF-8"?>
            <company>
                <name>IT-Heaven</name>
                <offices>
                    <office floor="1" room="1">
                        <employees>
                            <employee name="Maksim" job="Middle Software Developer"></employee>
                            <employee name="Ivan" job="Junior Software Developer"/>
                        </employees>
                    </office>
                    <office floor="1" room="2">
                        <employees>
                            <employee name="Herald" job="Middle Software Developer"/>
                            <employee name="Adam" job="Middle Software Developer"/>
                        </employees>
                    </office>
                </offices>
            </company>

                В этом примере:
                    - имя и должность каждого работника  - это его атрибуты
                    - внутри сущности (тега) employee ничего нет, все элементы employee – пустые.
                            - employee можно сделать пустым элементов - закрыть его сразу после объявления атрибутов
                                        <employee name="Ivan" job="Junior Software Developer"/>

    Последняя конструкция – это CDATA, означает «символьные данные».
            - благодаря данной конструкции, можно записывать текст, который не будет интерпретироваться как разметка XML.
            - полезно, если внутри XML файла у вас есть сущность, которая хранит в информации XML разметку

                        <?xml version="1.0" encoding="UTF-8" ?>
                            <bean>
                                <information>
                                    <![CDATA[<name>Ivan</name><age>26</age>]]>
                                </information>
                            </bean>

        Важно понимать:
            - придумывать свои элементы и атрибуты можно, но это не гибко
            - так как если кто-то захочет перенести элемент name в атрибуты, а вся логика программы написана так,
              чтобы name был элементом, файл поломается
            - чтобы создать свои собственные правила (стандарты) того:
                    - какие элементы должны быть,
                    - какие атрибуты у них есть и другие вещи
                    - можно было проводить валидацию XML файлов
            - есть специальные средства (самые известные):
                    - DTD
                    - XML Schema


    --------------------------------------------------- DTD ------------------------------------------------------------
        Создан для того, чтобы описывать типы документов.
        Это технология валидации XML-документов.
        DTD объявляет конкретные правила для типа документа:
                - его элементы,
                - какие элементы могут быть внутри элемента,
                - атрибуты,
                - обязательные они или нет,
                - количество их повторений,
                - а так же сущности (Entity).

        Например:
                        <!-- Объявление возможных элементов -->
                                <!ELEMENT company (name, offices)>
                                <!ELEMENT name (#PCDATA)>
                                <!ELEMENT offices (office+)>
                                <!ELEMENT office (employees)>
                                <!ELEMENT employees (employee+)>
                                <!ELEMENT employee EMPTY>

                        <!-- Добавление атрибутов для элементов employee и office -->
                                <!ATTLIST office
                                    floor CDATA #REQUIRED
                                    room  CDATA #REQUIRED
                                >
                                <!ATTLIST employee
                                    name CDATA #REQUIRED
                                    job  CDATA #REQUIRED
                                >

                        <!-- Добавление сущностей -->
                                <!ENTITY M "Maksim">
                                <!ENTITY I "Ivan">

        Для создания DTD файлов служат 3 основные конструкции, чтобы описывать любые XML файлы:
            -   ELEMENT (для описания элементов),
            -   ATTLIST (для описания атрибутов для элементов)
            -   ENTITY  (для подстановки текста сокращенными формами)

            ELEMENT
                - служит для описания элемента
                - элементы, которые можно использовать внутри описанного элемента, перечисляются в скобках в виде списка.
                - можно использовать квантификаторы для указания количества:
                            + значит 1+
                            * значит 0+
                            ? значит 0 ИЛИ 1
                            если квантификаторов не было добавлено, то считается, что должен быть только 1 элемент
                - если нужен один из группы элементов:
                            <!ELEMENT company ((name | offices))>
                                - в этом случае выбирается один из элементов:
                                     name или offices, но если бы внутри company было сразу два их, то валидация бы не проходила
                - EMPTY   – элемент должен быть пустым
                - ANY     – любые элементы
                - #PCDATA – текстовые данные

            ATTLIST
                - служит для добавления атрибутов к элементам
                - после ATTLIST следует:
                        - название элемента
                        - словарь вида «название атрибута – тип атрибута»
                                - CDATA – текстовые данные
                                - есть и другие типы, однако все они строчные
                        - в конце можно добавить:
                                - #IMPLIED (не обязателен)
                                - #REQUIRED (обязателен)

                        <!-- Добавление сущностей -->
                                <!ENTITY M "Maksim">
                                <!ENTITY I "Ivan">

            ENTITY
                - служит для объявления сокращений и текста, который будет на них подставляться
                    - по сути, сможем использовать вместо полного текста просто в формате (&название сущности;)

                Например: чтобы отличать разметку в HTML и просто символы, левую угловую скобочку часто экранируют с помощью lt; ,
                только нужно еще выставить & перед lt.
                Тогда мы будем использовать не разметку, а просто символ < .

        Есть два способа использовать объявленные правила в ХМL:
                - внедрение
                - импорт

            1. Внедрение - написание DTD правил внутри самого XML файла:
                                    - пишем корневой элемент после ключевого слова DOCTYPE
                                    - заключаем наш DTD файл внутри квадратных скобочек

                            <?xml version="1.0" encoding="UTF-8"?>
                            <!DOCTYPE company [
                                                    <!-- Объявление возможных элементов -->
                                                        <!ELEMENT company (name, offices)>
                                                        <!ELEMENT name (#PCDATA)>
                                                        <!ELEMENT offices (office+)>
                                                        <!ELEMENT office (employees)>
                                                        <!ELEMENT employees (employee+)>
                                                        <!ELEMENT employee EMPTY>

                                                    <!-- Добавление атрибутов для элементов employee и office -->
                                                                <!ATTLIST office
                                                                    floor CDATA #REQUIRED
                                                                    room  CDATA #REQUIRED
                                                                >
                                                                <!ATTLIST employee
                                                                    name CDATA #REQUIRED
                                                                    job  CDATA #REQUIRED
                                                                >

                                                    <!-- Добавление сущностей -->
                                                        <!ENTITY M "Maksim">
                                                        <!ENTITY I "Ivan">
                                                        <!ENTITY F "Franklin">
                            ]>
                            <company>
                                <name>IT-Heaven</name>
                                <!-- Иван недавно уволился, только неделю отработать должен.-->
                                <offices>
                                    <office floor="1" room="1">
                                        <employees>
                                            <employee name="&M;" job="Middle Software Developer" />
                                            <employee name="&I;" job="Junior Software Developer" />
                                        </employees>
                                    </office>
                                    <office floor="1" room="2">
                                        <employees>
                                            <employee name="Herald" job="Middle Software Developer" />
                                            <employee name="Adam" job="Middle Software Developer" />
                                        </employees>
                                    </office>
                                </offices>
                            </company>

            2. Импорт
                    - записываем наши правила в отдельный DTD файл,
                    - после чего в XML файле используем DOCTYPE-конструкцию из первого способа,
                      только вместо квадратных скобочек нужно написать SYSTEM и указать абсолютный или относительный
                      до текущего местоположения файла путь

                            <?xml version="1.0" encoding="UTF-8"?>
                            <!DOCTYPE company SYSTEM "dtd_example1.dtd">

                            <company>
                                ..................
                            </company>

                    Так же можно использовать ключевое слово PUBLIC вместо SYSTEM - очень редко используется

        Однако, у DTD есть свои минусы:
            - у него свой собственный синтаксис, отличный от синтаксиса xml;
                        - нужно разбираться в синтаксисе XML и DTD
            - в DTD нет проверки типов данных, а содержать он может только строки;
                        - у атрибутов в DTD действительно есть разные типы, но все они, по сути своей,
                        являются строковыми представлениями чего-либо, списками или ссылками.
                        - не можно требовать только числа (тем более позитивные или негативные)
                        - про объектные типы можно вообще забыть
            - в DTD нет пространства имён

    ------------------------------------------------- XML Namespace ----------------------------------------------------
        Namespace -  «пространство имён»
        XML Namespace – это технология, основная цель которой - сделать так, чтобы все элементы были уникальными в XML
    файле и не было путаницы.

        В XML Namespace если элементы одинаковые, тогда нужно использовать их в разных namespace’ах, тогда даже если
    имена элементов cовпадают, мы все равно будем обращаться к конкретному элементу из пространства (пакета).
        Пример:     в XML есть два элемента – предсказание (oracle) и БД Oracle
                            <?xml version="1.0" encoding="UTF-8"?>
                            <root>
                                <oracle>
                                    <connection value="jdbc:oracle:thin:@10.220.140.48:1521:test1" />
                                    <user value="root" />
                                    <password value="111" />
                                </oracle>
                                <oracle>
                                    Сегодня вы будете заняты весь день.
                                </oracle>
                            </root>
                Для того, чтобы различать элементы можно каждому из элементов выделить свое собственное пространство,
           чтобы можно было их различать
                Для этого есть специальный атрибут:
                            – xmlns:префикс= «уникальное значение для namespace”.
                                    - после чего, мы можем использовать префикс перед элементами, чтобы указывать,
                                      что он является частью этого namespace
                            <?xml version="1.0" encoding="UTF-8"?>
                            <root>
                                <database:oracle xmlns:database="Unique ID #1">
                                    <connection value="jdbc:oracle:thin:@10.220.140.48:1521:test1" />
                                    <user value="root" />
                                    <password value="111" />
                                </database:oracle>
                                <oracle:oracle xmlns:oracle="Unique ID #2">
                                    Сегодня вы будете заняты весь день.
                                </oracle:oracle>
                            </root>

                    Еще пример:
                            <?xml version="1.0" encoding="UTF-8"?>
                            <root   xmlns="https://www.standart-namespace.com/"
                                    xmlns:gun="https://www.gun-shop.com/"
                                    xmlns:fish="https://www.fish-shop.com/">
                                <gun:shop>
                                    <gun:guns>
                                        <gun:gun name="Revolver" price="1250$" max_ammo="7" />
                                        <gun:gun name="M4A1" price="3250$" max_ammo="30" />
                                        <gun:gun name="9mm Pistol" price="450$" max_ammo="12" />
                                    </gun:guns>
                                </gun:shop>
                                <fish:shop>
                                    <fish:fishes>
                                        <fish:fish name="Shark" price="1000$" />
                                        <fish:fish name="Tuna" price="5$" />
                                        <fish:fish name="Capelin" price="1$" />
                                    </fish:fishes>
                                </fish:shop>
                            </root>

                        В примере используются пространства:
                            -   gun для уникальных элементов оружейного магазина
                            -   fish для уникальных элементов рыболовного магазина

           xmlns – атрибут для объявления namespace’а, можно указывать в любом элементе
                        xmlns:shop = «https://barber-shop.com/»
                              - после двоеточия находится префикс – это ссылка на пространство, которая потом может
                           использоваться перед элементами, чтобы указывать, что они родом из этого пространства
                              - значение xmlns должно быть УНИКАЛЬНОЙ СТРОКОЙ
                                (в основном используют URL адрес, но можно использовать любые строки)
                                        xmlns:oracle="Unique ID #2"
                                        xmlns:database="Unique ID #1"

           Когда вы объявляете namespace, вы можете его использовать в самом элементе и во всех элементах внутри него,
        потому объявленные в root элементе namespace’ы можно использовать во всех элементах.
            Пример объявления namespace в элементе:
                        <?xml version="1.0" encoding="UTF-8"?>
                        <root>
                            <el1:element1 xmlns:el1="Element#1 Unique String">
                                <el1:innerElement/>
                            </el1:element1>
                            <el2:element2 xmlns:el2="Element#2 Unique String">
                                <el2:innerElement></el2:innerElement>
                            </el2:element2>
                            <el3:element3 xmlns:el3="Element#3 Unique String">
                                <el3:innerElement>
                                    // так нельзя, так как пространство el1 объявлено только в первом элементе //
                                    <el1:innerInnerElement/>
                                </el3:innerElement>
                            </el3:element3>
                        </root>

            Важная деталь:      существует так же стандартный namespace в root элементе
                - если объявили другие namespace’ы, стирается стандартный и не можно его использовать.
                - тогда перед root элементом нужно поставить какой-то префикс пространства, любой, который вы объявили ранее
                - однако, это можно так же обхитрить:  можно объявить стандартное пространство явно
                        - достаточно просто не использовать префикс после xmlns, а сразу записать какое-то значение,
                          и все ваши элементы без префикса станут принадлежать именно этому namespace’у.

                                <root xmlns="https://www.standart-namespace.com/"
                                      xmlns:gun="https://www.gun-shop.com/"
                                      xmlns:fish="https://www.fish-shop.com/">

                                    Объявили стандартное пространство явно, чтобы избежать необходимости использовать gun или fish,
                                так как рут элемент не является сущностью ни рыболовного магазина, ни оружейного,
                                потому использование любого пространства было бы уже логически неправильным

            Далее:
                - если создали xmlns:a и xmlns:b, но у них одно значение, то это одинаковое пространство и они не уникальные
                                <root xmlns="https://www.standart-namespace.com/"
                                      xmlns:gun="https://www.gun-shop.com/"
                                      xmlns:fish="https://www.gun-shop.com/">
                                    В таком случае наш раболовный магазин стал бы оружейным, а префикс был бы еще рыбного магазина


    -------------------------------------------------- XML Schema ------------------------------------------------------
        В данном разедле написаны основы работы XML Schema.

        Схемы обладают форматом .xsd (xml scheme definition) и являются более продвинутой льтернативой DTD:
                -   они способны так же создавать элементы, описывать их и так далее
                -   а также проверка типов, поддержка нэймспэйсов и более широкий функционал

        В XSD проблема с поддержкой пространства решена:
                - можно импортировать схемы в одно конкретное пространство и использовать его.
                - по сути, у каждой XSD схемы есть целевое пространство, которое означает, в какое пространство должна
                  быть записана схема в XML файле
                        - в самом XML файле нам нужно создать эти заранее определенные в схемах пространства
                        - и назначить префиксы для них, а потом подключить в каждое из них нужные схемы,
                        - после чего мы можем спокойно использовать элементы из схемы, подставляя префиксы из того пространства,
                          куда мы импортировали схемы

        Пример:
                        <?xml version="1.0" encoding="UTF-8"?>
                        <house>
                            <address>ул. Есенина, дом №5</address>
                            <owner name="Ivan">
                                <telephone>+38-094-521-77-35</telephone>
                            </owner>
                        </house>

                Хотим валидировать его с помощью схемы. Для начала, нам нужна схема:
                        <?xml version="1.0"?>
                        <schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="https://www.nedvigimost.com/">
                            <element name="house">
                                <complexType>
                                    <sequence>
                                        <element name="address" type="string" maxOccurs="unbounded" minOccurs="0" />
                                        <element name="owner" maxOccurs="unbounded" minOccurs="0" >
                                            <complexType>
                                                <sequence>
                                                    <element name="telephone" type="string" />
                                                </sequence>
                                                <attribute name="name" type="string" use="required"/>
                                            </complexType>
                                        </element>
                                    </sequence>
                                </complexType>
                            </element>
                        </schema>
                            - из примера видно, что схема - это тоже XML файл
                            - в ней на XML языке расписываете то, что вам нужно
                            - данная схема способна валидировать XML файл из примера выше.

                                Например:
                                    - если у owner не будет имени, то схема это увидит
                                    - благодаря элементу sequence, всегда должен идти сначала адрес, а потом владелец дома.

        Есть элементы:
            - обычные       -   это элементы, которые хранят в себя только какой-то тип данных
                                            <element name="telephone" type="string"/>
                                                - так мы объявляем элемент, который хранит в себе строку
                                                - других элементов быть внутри этого элемента не должно
            - комплексные   -   это элементы, которые способны хранить внутри себя другие элементы, атрибуты
                                    - тогда тип указывать не нужно, а достаточно внутри элемента начать писать комплексный тип
                                            <complexType>
                                                // внутри все из примера выше
                                            </complexType>

        Так же можно было поступить по-другому:
            -   можно было создать комплексный тип отдельно, а потом подставлять его в type.
                    - только во время написания этого примера, почему-то нужно объявлять пространство под каким-то префиксом,
                      а не использовать стандартное
                            <?xml version="1.0"?>
                            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="https://www.nedvigimost.com/">
                                <xs:element name="house" type="content" />
                                <xs:complexType name="content">
                                    <xs:sequence>
                                        <xs:element name="address" type="xs:string" maxOccurs="unbounded" minOccurs="0" />
                                        <xs:element name="owner" maxOccurs="unbounded" minOccurs="0" >
                                            <xs:complexType>
                                                <xs:sequence>
                                                    <xs:element name="telephone" type="xs:string" />
                                                </xs:sequence>
                                                <xs:attribute name="name" type="xs:string" use="required"/>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:schema>

                                 - мы можем создавать наши собственные типы отдельно
                                 - после чего подставлять их куда-либо в атрибут type
                            это позволяет использовать один тип в разных местах


        Есть два способа подключить схему:
            - в конкретное пространство
            - просто подключить

        Первый способ подключения схемы:
            - первый способ подразумевает, что у схемы есть конкретное целевое пространство.
            - оно указывается с помощью атрибута targetNamespace у элемента scheme.
            - тогда достаточно создать ЭТО САМОЕ пространство в XML файле, после чего «загрузить» туда схему:
                            <?xml version="1.0" encoding="UTF-8"?>
                            <nedvig:house xmlns:nedvig="https://www.nedvigimost.com/"
                                          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                          xsi:schemaLocation="https://www.nedvigimost.com/  example_schema1.xsd">
                                <address>ул. Есенина, дом №5</address>
                                <owner name="Ivan">
                                    <telephone>+38-094-521-77-35</telephone>
                                </owner>
                            </nedvig:house>

            Важно понимать две строчки:
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemeLocation="https://www.nedvigimost.com/ example_schema1.xsd"

                    Первая строчка – просто запомните её.
                                     считайте, что это объект, который помогает загружать схемы туда, куда надо.

                    Вторая строчка – уже конкретная загрузка.
                                     schemaLocation принимает список значений вида «значение – значение», разделенные пробелом.

                            Первый аргумент – пространство имён, которое должно соответствовать целевому пространству имён в схеме
                                              (значению targetNamespace).
                            Второй аргумент – относительный или абсолютный путь к схеме
                                                    - так, как это СПИСОК значений, можно после схемы в примере поставить пробел,
                                                       и снова ввести целевое пространство и имя другой схемы, и так сколько нужно

            Важно:   чтобы схема потом валидировала что-либо, вам нужно объявить это пространство и с префиксом использовать
                     - в примере создали это целевое пространство на префиксе nedvig, а потом использовали его
                     - таким образом, наши элементы начали валидироваться, так как мы начали использовать пространство
                       куда ссылается целевое пространство схемы


        Второй способ подключения схемы:
            Подразумевает, что у схемы нет конкретного целевого пространства
            Тогда можно просто подключить её к XML файлу и она будет валидировать его.

            Делается почти так же, только можно не объявлять пространства вообще в XML файле, а просто подключить схему.

                    <?xml version="1.0" encoding="UTF-8"?>
                    <house xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:noNamespaceSchemaLocation="example_schema1.xsd">
                           <address>ул. Есенина, дом №5</address>
                           <owner name="Ivan">
                                <telephone>+38-094-521-77-35</telephone>
                           </owner>
                    </house>
                        - делается это с помощью noNamespaceSchemaLocation и указанием пути к схеме
                        - даже если у схемы нет целевого пространства, документ будет валидироваться


        Последний штрих:
            Можно импортировать в схемы другие схемы, после чего использовать элементы из одной схемы в другой.
          Таким образом, можно использовать в одних схемах элементы, которые есть уже в других

            Схема, где объявляется тип owner:
                        <?xml version="1.0" encoding="UTF-8" ?>
                        <schema targetNamespace="bonus"
                                xmlns="http://www.w3.org/2001/XMLSchema"
                                elementFormDefault="qualified">
                            <complexType name="owner">
                                <all>
                                    <element name="telephone" type="string" />
                                </all>
                                <attribute name="name" type="string" />
                            </complexType>
                        </schema>

            Вторая схема, где используется тип owner из первой схемы:
                        <?xml version="1.0" encoding="UTF-8"?>
                        <schema targetNamespace="main"
                                xmlns="http://www.w3.org/2001/XMLSchema"
                                xmlns:bonus="bonus" elementFormDefault="qualified">
                                <import namespace="bonus" schemaLocation="xsd2.xsd" />
                            <element name="house">
                                <complexType>
                                    <all>
                                        <element name="address" type="string" />
                                        <element name="owner" type="bonus:owner" />
                                    </all>
                                </complexType>
                            </element>
                        </schema>
                            Во второй схеме используется конструкция:
                                  - <import ... /> - импортируем тип и элементы из одной схемы в другую с пространством bonus
                                  - таким образом получили доступ к типу bonus:owner
                                  - <element name="owner" type="bonus:owner" />  - использовали его

                            elementFormDefault="qualified" - атрибут объявляется в schema и означает, что в XML файлах каждый элемент
                                                             должен объявляться с явным префиксом перед ним
                                                               Если его нет, то нам достаточно объявить внешний элемент с префиксом,
                                                             а так нужно выставлять префиксы и во всех элементах внутри,
                                                             явно указывая, что мы используем именно элементы этой схемы.

            Пример XML файла валидируемого схемой, которая импортировала другую схему:
                            <?xml version="1.0" encoding="UTF-8"?>
                            <nedvig:house xmlns:nedvig="main" xmlns:bonus="bonus"
                                          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                          xsi:schemaLocation="main xsd.xsd">
                                <nedvig:address>ул. Есенина, дом №5</nedvig:address>
                                <nedvig:owner name="Ivan">
                                    <bonus:telephone>+38-094-521-77-35</bonus:telephone>
                                </nedvig:owner>
                            </nedvig:house>
                    В строчке:
                            <bonus:telephone>+38-094-521-77-35</bonus:telephone>  нужно явно объявлять пространство
                        имен bonus, указывающее на целевое пространство первой схемы, так как
                        elementFormDefault у нас в qualified (проверять), потому все элементы должны явно указывать свое пространство



------------------------------------------------ DOM, SAXParser --------------------------------------------------------
        Существуют две стратегии обработки XML документов:
            -  DOM (Document Object Model)
                    - позволяет читать и вносить изменения в XML, а также создавать новый
                    - весь документ XML помещается в память, потом редактируется
            -  SAX (Simple API for XML)
                    - содержимое XML документа только анализируется
                    - не помещая в память  обрабатывает XML-документ последовательно, поэтому не требует дополнительной памяти

        Разница между данными инструментами в функциональности и скорости работы.
            -  DOM  - если нужен более гибкий функционал и есть возможность тратить производительность     (функциональность)
            -  SAX  - последовательно считываем, поэтому менее затратный                                   (производительность)












        --------------------------------------------- DOM --------------------------------------------------------------
            DOM (Document Object Model) - обработчик устроен так, что он считывает сразу весь XML и сохраняет его,
        создавая иерархию в виде дерева, по которой мы можем спокойно двигаться и получать доступ к нужным нам элементам
            Таким образом, имея ссылку на верхний элемент, можем получить все ссылки на его внутренние элементы.
            При чем элементы, которые внутри элемента – дети этого элемента, а он – их родитель

            В DOM есть множество интерфейсов, которые созданы, чтобы описывать разные данные.
        Все эти интерфейсы наследуют один общий интерфейс – Node (узел). Так как  самый частый тип данных в DOM – это Node (узел),
        который может быть всем

            XML документ представляет собой набор узлов (тегов).
            DOM - это объектная модель документа, которая представляет собой дерево XML в виде специальных объектов/узлов Node
        Каждый узел Node соответствует своему XML-тегу и содержит полную информацию о том, что это за тег, какие он имеет атрибуты,
        какие дочерние узлы содержит внутри себя и т.д.
             На самой вершине этой иерархии находится Document, который является корневым элементов дерева.

        У каждого Node есть методы для извлечения информации:
            - getParentNode                 – возвращает узел, внутри которого находится данный узел
            - getChildNodes                 – возвращает все производные узлы (узлы, которые внутри данного узла)
            - getFirstChild/getLastChild    – возврващает первый/последний производный узел
            - getNodeType                   – возвращает тип узла
            - getNodeName                   – возвращает имя узла
            - getNodeValue                  – возвращает значение узла
            - getAttributes                 – возвращает все атрибуты узла
            - getTextContent                – возвращает весь текст внутри элемента и всех элементов внутри данного элемента,
                                              включая переносы строчек и пробелы
            - getOwnerDocument              – возввращает документ этого узла
            - getLocalName                  – полезно при обработка пространств имён, чтобы получить имя без префикса
                                                    - будет всегда возвращать null, если в DocumentFactory
                                                      не воспользоваться методом setNamespaceAware(true),
                                                      для запуска обработки пространств имён


        Важная деталь:
            методы общие для всех Node, но в Node у нас может быть как элемент, так и атрибут, поэтому возникает проблема
                - какое значение может быть у элемента?
                - какие производные узлы могут быть у атрибута? И другие не состыковки.

            Каждый метод будет работать в зависимости от типа Node.
            В официальных доках есть очень полезная табличка по работе каждого метода в зависимости от типа Node:
        Interface	               nodeName	                    nodeValue	                                             attributes
        Attr	                same as Attr.name           same as Attr.value	                                            null
        CDATASection	        "#cdata-section"	        same as CharacterData.data, the content of the CDATA Section	null
        Comment	                "#comment"	                same as CharacterData.data, the content of the comment	        null
        Document	            "#document"	                null	                                                        null
        DocumentFragment	    "#document-fragment"	    null	                                                        null
        DocumentType	        same as DocumentType.name   null	                                                        null
        Element	                same as Element.tagName     null	                                                    NamedNodeMap
        Entity	                entity name	                null	                                                        null
        EntityReference	        name of entity referenced	null	                                                        null
        Notation	            notation name	            null	                                                        null
        ProcessingInstruction	same as
                                ProcessingInstruction.target same as ProcessingInstruction.data	                            null
        Text	                "#text"	                     ame as CharacterData.data, the content of the text node	    null

            Самое важное, что нужно запомнить:
                - атрибуты есть ТОЛЬКО у элементов
                - у элементов НЕТ значения
                - имя узла-элемента совпадает с именем тега, а узла-атрибута с именем атрибута

        Задача №1 – нужно достать из 1.1_exam.xml информацию о всех сотрудниках и вывести её в консоль :

        Задача №2 – вводится с консоли имя элемента, про который нужно вывести информацию об всех элементах внутри его
                    и их атрибутах с 1.2_exam.xml

        Задача №3 – из 1.3_exam.xml  нужно считать информацию и вывести её в консоль



        --------------------------------------------- SAX --------------------------------------------------------------
            SAX-обработчик устроен так, что он просто считывает последовательно XML файлы и реагирует на разные события,
        после чего передает информацию специальному обработчику событий.
            У него есть немало событий, однако самые частые и полезные следующие:
                -   startDocument           — реакция на начало документа
                -   startElement            — реакция на открытие элемента
                -   characters              — реакция на текстовую информация внутри элемента
                -   ignorableWhitespace     — реакция на пустое пространство внутри элемента (пробелы, переносы строчек и т.д.)
                -   endElement              — реакция на закрытие элемента
                -   endDocument             — реакция на конец документа

            Все события обрабатываются в обработчике событий, который нужно создать и переопределить методы.

            Преимущества:
                -   высокая производительность благодаря "прямому" способу считывания данных
                -   низкие затраты памяти

            Недостатки:
                -   ограниченная функциональность, поэтому в нелинейных задачах дорабатывать её надо самостоятельно

            В методах startElement и endElement:
                - uri       — это пространство, в котором находится элемент,
                - localName — это имя элемента без префикса,
                - qName     — это имя элемента с префиксом (если он есть, иначе просто имя элемента).

                uri и localName всегда пустые, если мы не подключили в фабрике обработку пространств.
                     - это делается методом фабрики setNamespaceAware(true)
                       тогда мы сможем получать пространство (uri) и элементы с префиксами перед ними (localName)

            Задача №1   -   из 1.1_exam.xml достать всю информацию про всех сотрудников

            Задача №2   -   из 2_exam.xml достать всю информацию про всех сотрудников
                - в задаче хорошо продемонстрировано как плохо структурированный XML усложняет написание кода
                - в данном случае информация про имя и должность хранится как текстовая информация внутри элементов
                - логика решения:
                        - в примере всегда name и job идут по очереди (порядок не имеет значения)
                        - поэтому сохраняем имя и профессию в отдельные переменные
                        - создаем сотрудника

            Задача №3   -   в 1.2_exam.xml, из элемента "root" (или "mysql", "oracle")
                            вывести имена  и атрибуты внутренних элементов, если элемент не найдет - вывести это
                - логика решения:
                        - при входе в элемент, про который нужна информация, выставляем флажок isEntered в true,
                          означая, что внутри элемента
                        - когда оказались внутри элемента, каждый новый элемент  обрабатываем в startElement
                          согласно требований задачи
                        - при выходе из элемента сновы выставляем флажок isEntered = false


            ------------------------------------- Interface XMLStreamReader --------------------------------------------
                Интерфейс XMLStreamReader обеспечивает прямой доступ к XML только для чтения.
                Разработан как самый низкоуровневый и наиболее эффективный способ чтения данных XML.

                XMLStreamReader предназначен для итерационного просмотра XML с помощью:
                    - next()
                    - hasNext()

                Доступ к данным можно получить с помощью таких методов:
                    - getEventType()
                    - getNamespaceURI()
                    - getLocalName()
                    - getText()

                Экземпляр XMLStreamReader создается с начальным типом события START_DOCUMENT.
                В любой момент времени у него есть текущее событие, к которому обращаются методы интерфейса, и он может
            загрузить следующее событие через метод next()
                Текущий тип события может быть определен с помощью getEventType(), а следующий тип события может быть
            возвращен методом next()

                События разбора определяются как:
                    - декларация XML,
                    - DTD,
                    - начальный тег,
                    - символьные данные,
                    - пробел,
                    - конечный тег,
                    - комментарий или инструкция по обработке.
                Событие атрибута или пространства имен может быть встречено на корневом уровне документа в результате
            операции запроса.

                Для совместимости с XML 1.0 процессор XML должен передавать в приложение:
                    - идентификаторы объявленных неанализируемых объектов,
                    - объявления нотации и связанные с ними идентификаторы.
                Эта информация предоставляется через API свойств в этом интерфейсе.
                Следующие два свойства разрешают доступ к этой информации:
                    - javax.xml.stream.notations
                    - javax.xml.stream.entities.

                Когда текущее событие является DTD, следующий вызов вернет
            список Notations List l = (List) getProperty("javax.xml.stream.notations");
                Следующий вызов вернет список объявлений сущностей: List l = (List) getProperty("javax.xml.stream.entities");
                К этим свойствам можно получить доступ только во время события DTD, и они определены для возврата значения null,
            если информация недоступна.

                В следующей таблице описано,какие методы действительны в каком состоянии.
            Если метод вызывается в недопустимом состоянии,то метод вызовет исключение java.lang.IllegalStateException.

                Тип события	                            Valid Methods
                    	            getProperty(), hasNext(), require(), close(), getNamespaceURI(), isStartElement(),
            All States              isEndElement(), isCharacters(), isWhiteSpace(), getNamespaceContext(),
                                    getEventType(), getLocation(), hasText(), hasName()
            START_ELEMENT	        next(), getName(), getLocalName(), hasName(), getPrefix(), getAttributeXXX(),
                                    isAttributeSpecified(), getNamespaceXXX(), getElementText(), nextTag()
            ATTRIBUTE	            next(), nextTag(), getAttributeXXX(), isAttributeSpecified()
            NAMESPACE	            next(), nextTag(), getNamespaceXXX()
            END_ELEMENT	            next(), getName(), getLocalName(), hasName(), getPrefix(), getNamespaceXXX(), nextTag()
            CHARACTERS	            next(), getTextXXX(), nextTag()
            CDATA	                next(), getTextXXX(), nextTag()
            COMMENT	                next(), getTextXXX(), nextTag()
            SPACE	                next(), getTextXXX(), nextTag()
            START_DOCUMENT	        next(), getEncoding(), getVersion(), isStandalone(), standaloneSet(), getCharacterEncodingScheme(),
                                    nextTag()
            END_DOCUMENT	        close()
            PROCESSING_INSTRUCTION	next(), getPITarget(), getPIData(), nextTag()
            ENTITY_REFERENCE	    next(), getLocalName(), getText(), nextTag()
            DTD	                    next(), getText(), nextTag()

            Методы (более детально про методы  - https://runebook.dev/ru/docs/openjdk/java.xml/javax/xml/stream/xmlstreamreader):
                void close()	                            -   освобождает все ресурсы,связанные с данным считывателем

                int	getAttributeCount()                     -   возвращает количество атрибутов данного START_ELEMENT,
                                                                этот метод действителен только для START_ELEMENT или ATTRIBUTE
                String	getAttributeLocalName(int index)	-   возвращает локальное имя атрибута по указанному индексу
                QName	getAttributeName(int index)	        -   возвращает qname атрибута по указанному индексу
                String	getAttributeNamespace(int index)	-   возвращает пространство имен атрибута по указанному индексу
                String	getAttributePrefix(int index)	    -   возвращает префикс данного атрибута по указанному индексу
                String	getAttributeType(int index)	        -   возвращает XML-тип атрибута по указанному индексу
                String	getAttributeValue(int index)	    -   возвращает значение атрибута по индексу
                String	getAttributeValue (String namespaceURI, String localName)	- возвращает нормализованное значение атрибута
                                                                                      с пространством имен и localName
                                                                                         если namespaceURI равен null,то пространство
                                                                                      имен не проверяется на равенство.

                String	getCharacterEncodingScheme()    -   возвращает кодировку символов, объявленную в объявлении xml
                                                            Возвращает null, если она не была объявлена
                String	getElementText()                -	считывает содержимое элемента,содержащего только текст;
                                                               если элемент не является элементом, содержащим только текст,
                                                            возникает исключение.
                String	getEncoding()                   -	возвращает входную кодировку, если известна, или null, если неизвестна
                int	getEventType()                      -	возвращает целочисленный код, указывающий на тип события,
                                                            на которое указывает курсор
                String	getLocalName()	                -   возвращает (локальное) имя текущего события
                Location	getLocation()	            -   возвращает текущее местоположение процессора
                QName	getName()	                    -   возвращает QName для текущего события START_ELEMENT или END_ELEMENT
                NamespaceContext getNamespaceContext()	-   возвращает контекст пространства имен только для чтения для текущей позиции
                int	getNamespaceCount()	                -   возвращает количество пространств имен, объявленных в данном START_ELEMENT
                                                            или END_ELEMENT.
                                                              Метод действителен только для START_ELEMENT, END_ELEMENT или NAMESPACE.
                String	getNamespacePrefix(int index)   -	возвращает префикс для пространства имен, объявленного по индексу
                String	getNamespaceURI()	            -   если текущее событие является START_ELEMENT или END_ELEMENT,
                                                            метод возвращает URI префикса или пространства имен по умолчанию
                String	getNamespaceURI(int index)	    -   возвращает uri для пространства имен, объявленного в индексе
                String	getNamespaceURI(String prefix)	-   возвращает uri для заданного префикса.
                String	getPIData()	                    -   получение раздела данных инструкции обработки
                String	getPITarget()	                -   получение цели инструкции по обработке
                String	getPrefix()	                    -   возвращает префикс текущего события или null, если событие не имеет
                                                            префикса
                Object	getProperty(String name)	    -   получить значение характеристики/свойства из базовой реализации
                String	getText()	                    -   возвращает текущее значение события разбора в виде строки,
                                                                - возвращает строковое значение события CHARACTERS,
                                                                - возвращает значение COMMENT,
                                                                - значение замены для ENTITY_REFERENCE,
                                                                - строковое значение секции CDATA,
                                                                - строковое значение для события SPACE
                                                                - или строковое значение внутреннего подмножества DTD.
                char[]	getTextCharacters()	            -   возвращает массив, содержащий символы из этого события
                int	getTextCharacters(int sourceStart, char[] target, int targetStart, int length)
                                                        -   получает текст, связанный с событием CHARACTERS, SPACE или CDATA
                int	getTextLength()	                    -   возвращает длину последовательности символов для данного события Text
                                                            в массиве символов текста
                int	getTextStart()	                    -   возвращает смещение в массиве текстовых символов,
                                                            где хранится первый символ (данного текстового события).
                String	getVersion()	                -   получить версию xml, объявленную в объявлении xml
                                                            Возвращает null,если она не была объявлена

                boolean	hasName()	    - указывает имеет ли текущее событие имя (является ли оно START_ELEMENT или END_ELEMENT).
                boolean	hasNext()	    - true,если есть еще события парсинга, и false, если событий больше нет.
                boolean	hasText()	    - указывает есть ли в текущем событии текст
                boolean	isAttributeSpecified(int index)	    - указывает, был ли этот атрибут создан по умолчанию
                boolean	isCharacters()	- true, если курсор указывает на событие данных символа
                boolean	isEndElement()	- true,если курсор указывает на конечный тег (иначе false)
                boolean	isStandalone()	- получение автономной декларации из декларации xml
                boolean	isStartElement()- true, если курсор указывает на начальный тег (иначе false)
                boolean	isWhiteSpace()  - true,если курсор указывает на событие символьных данных, состоящее из пробельных символов


                int	next()	                -   получить следующее событие разбора-процессор может вернуть все непрерывные символьные
                                            данные в одном чанке или разбить их на несколько чанков
                int	nextTag()	            -   пропускает любые пробелы (isWhiteSpace()возвращает true),COMMENT или PROCESSING_INSTRUCTION,
                                            пока не будет достигнут START_ELEMENT или END_ELEMENT.

                boolean	standaloneSet()     - проверяет, была ли установлена автономность в документе
                void require(int type, String namespaceURI, String localName)
                                            - проверяет,имеет ли текущее событие заданный тип и совпадают ли пространство имен
                                              и имя с текущим пространством имен и именем текущего события