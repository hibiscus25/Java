    1. Общее:
            - лямбда - выражение можно рассматривать как некоторый блок кода, определяющий действие;
            - в основном лямбда-выражение используется как альтернатива к созданию анонимного класса;
            - используется только когда интерфейс:
                    - имеет один абстрактный метод
                    - является функциональным интерфейсом с одним абстрактным методом

    2. Шаблон:
            (аргументы) -> {  тело с командами  }

            (int x, int y) -> {
                                int z = x+y;
                                System.out.println(z);
                               }

    3. Правила, которые позволяют упрощать синтаксис лямбда - выражений:
        - тип аргумента можно не указывать, если он индентифицируется исходя из контекста команды использования л-выражения;
        - если в лямбда-выражении один аргумент, тип которого не указан, то круглые скобки можно не использовать;
        - если в лямбда-выражении нет аргументов, то используются пустые круглые скобки;
        - если в теле лямбда-выражения всего одна команда, то фигурные скобки можно не использовать;
                - в случае, когда единственная команда в теле лямбда - оператора состоит из return - инструкции,
          слово return можно не использовать.

    4. Лямбда - выражению может быть присвоено значение переменной интерфейсного типа при условии:
          - сигнатура абстрактного метода в интерфейсе соответствует параметрам лямбда - выражения (количество и тип)

    5. При присваивании интерфейсной переменной значением лямбда - выражения происходит следующее:
          - создается объект на основе (анонимного) класса, который реализует интерфейс,
            а в качестве кода для определения абстрактного метода используется код лямбда - выражения

                            interface MyName{
                                void get();
                            }
                            .................
                            MyName a = new MyName(){
                                public void get() {
                                    System.out.println("Hello");
                                }
                            }
                P.S: в этом выражении используется свойство, что интерфейсная переменная может содержать ссылку
                     на объект класса, реализующего данный интерфейс

    6. Шаблоны выполнения ссылки на:
            - нестатический метод Объекта
                    - без аргументов
                            - объект :: имя_метода       соответствует      () -> obj.get();**
                    - с аргументами
                            - объект :: имя_метода       соответствует      (k) -> obj.set(k);**
                                ** - в таком случае должно быть  final MyClass obj

            - нестатический метод Класса
                    - без аргументов
                            - класс::имя_метода           соответствует     (MyClass ob) -> ob.get();
                    - с аргументами
                            - класс::имя_метода           соответствует     (MyClass ob,int k) -> {ob.set(k)}

            - статический метод Класса
                    - без аргументов
                            - класс::имя_метода           соответствует     () -> MyClass.get();
                    - с аргументами
                            - класс::имя_метода           соответствует     (int k) -> MyClass.set(k);

            - перегруженный метод Объекта
                    - для использования нужного перегруженного метода, выбираем соответствующий интерфейс
                 у которого совпадает тип и количество аргументов

            - конструктор Класса
                    - без аргументов
                            - класс::new                  соответствует     () -> new MyClass();
                    - с аргументами
                            - класс::new                  соответствует     (k) -> new MyClass();


    7. Встроенные функциональные интерфейсы:
            В JDK 8 вместе с самой функциональностью лямбда-выражений также было добавлено некоторое количество (более 40)
        встроенных функциональных интерфейсов, которые мы можем использовать в различных ситуациях:
                -   Predicate<T>        -   проверяет соблюдение некоторого условия
                                                - если оно соблюдается, то возвращается значение true
                                                - в качестве параметра лямбда-выражение принимает объект типа T
                                                            public interface Predicate<T>
                                                                boolean test(T t);

                -   BinaryOperator<T>   -   принимает в качестве параметра два объекта типа T,  выполняет над ними бинарную
                                            операцию и возвращает ее результат также в виде объекта типа T
                                                            public interface BinaryOperator<T>
                                                                T apply(T t1, T t2);

                -   UnaryOperator<T>    -   принимает в качестве параметра объект типа T,
                                            выполняет над ними операции и возвращает результат операций в виде объекта типа T
                                                            public interface UnaryOperator<T>
                                                                T apply(T t);

                -   Function<T,R>       -   представляет функцию перехода от объекта типа T к объекту типа R
                                                            public interface Function<T, R>
                                                                R apply(T t);

                -   Consumer<T>         -  выполняет некоторое действие над объектом типа T, при этом ничего не возвращает
                                                            public interface Consumer<T>
                                                                void accept(T t);

                -   Supplier<T>         -  не принимает никаких аргументов, но должен возвращать объект типа T
                                                            public interface Supplier<T>
                                                                T get();