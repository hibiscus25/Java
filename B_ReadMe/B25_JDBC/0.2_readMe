
    1. класс DriverManager является уровнем управления JDBC, он
            - отслеживает все доступные драйверы и
            - управляет установлением соединений между БД и соответствующим драйвером

        Чтобы сказать  DriverManager, какой именно драйвер следует загрузить, необходимо выполнить одну из команд :
            - Class.forName(“полное имя класса”)
            - Class.forName(“полное имя класса”).newInstance()
            - DriverManager.registerDriver(new “полное имя класса”)

        Устанавливать  соединения с БД можно сразу после регистрации драйвера JDBC, для этого вызывается метод
    DriverManager.getConnection


    2. Transaction включает одно или несколько изменений в базе данных, которые после выполнения
            - либо все фиксируются (commit),
            - либо все откатываются назад (rollback).
        При вызове метода commit или rollback текущая транзакция заканчивается и начинается другая.

    Типы уровней изолированности
       TRANSACTION_NONE                 -   транзакции не поддерживаются
       TRANSACTION_READ_COMMITTED       -   запрет на «грязное чтение» (dirty read)
                                            Блокирует транзакциям чтение строк с неподтвержденными изменениями в них
       TRANSACTION_READ_UNCOMMITTED     -   разрешение на «dirty read»
                                            Позволяет изменять строку с помощью одной транзакции и прочесть ее другой прежде,
                                            чем изменения в этой строке будут подтверждены (dirty read).
                                                Если изменения будут отменены с помощью rollback(),
                                            вторая транзакция вернет неправильную строку
       TRANSACTION_REPEATABLE_READ      -   запрет на «dirty read».
                                            Препятствует транзакции от чтения строки с неподтвержденным изменением в ней,
                                            он также предотвращает ситуацию, когда одна транзакция читает строку,
                                            а вторая транзакция изменяет ее, при этом первая транзакция перечитывая строку,
                                            получает разные значения каждый раз (разовое чтение).
       TRANSACTION_SERIALIZABLE         -   запрет на «dirty read».
                                            Включает предотвращения из TRANSACTION_REPEATABLE_READ,
                                            более того предотвращает ситуацию, когда
                                                - одна транзакция читает все строки, которые удовлетворяют условию WHERE,
                                                -  а вторая транзакция вставляет строку, которая удовлетворяет тому же условию WHERE,
                                            и первая транзакция, перечитывая с тем же условием,
                                            получает дополнительную «фантомную» строку при втором чтении.


    3. Для получения дополнительной информации MetaData JDBC включает два интерфейса:
            - DatabaseMetaData
            - ResultSetMetaData
       Дополнительная информация может быть следующей:
                - о параметрах подключения к серверу БД,
                - самой базе данных и
                - результирующему набору, извлекаемому из базы данных

       DatabaseMetaData и содержит методы,
            - описывающие таблицы базы данных,
            - поддержку SQL,
            - хранимые процедуры и
            - другие сведения, относящиеся к базе данных и текущему Connection, которые не относятся непосредственно
              к выполнению команд и извлечению результирующих наборов

            Основные методы:
                - getDatabaseProductName()	        Название сервера базы
                - getDatabaseProductVersion()	    Версия сервера
                - getDriverName()	                Имя драйвера
                - getDriverVersion()	            Версия драйвера
                - getUserName()	                    Пользователь
                - getTableTypes()	                Типы таблиц
                - getNumericFunctions()	            Математические функции
                - getStringFunctions()	            Строковые функции
                - getSystemFunctions()	            Системные функции
                - getTimeDateFunctions()	        Дата/Время функции
                - getExtraNameCharacters()	        Символы для имён, кроме стандартных
                - getSchemaTerm()	                Термин для "схема"
                - getProcedureTerm()	            Термин для "процедура"
                - getCatalogTerm()	                Термин для "каталог"
                - getMaxColumnNameLength()	        Макс. длина имени колонки
                - getMaxProcedureNameLength()	    Макс. длина имени процедуры
                - getMaxTableNameLength()	        Макс. длина имени таблицы
                - getMaxColumnsInSelect()	        Макс. кол-во колонок в SELECT
                - getMaxStatementLength()	        Макс. длина SQL запроса
                - getMaxColumnsInTable()	        Максимальное кол-во колонок в TABLE
                - getMaxConnections()	            Максимальное кол-во одновременных соединений с базой

       ResultSetMetaData определяет объект метаданных для текущего набора данных ResultSet.
    ResultSetMetaData содержит информацию о результирующей таблице
                                                - количество колонок,
                                                - тип значений колонок и т.д.


    4. Класс Statement используется для выполнения SQL-запросов.
            Существует три типа класса Statement, которые являются как бы контейнерами для выполнения SQL-выражений
       через установленное соединение:
                - Statement            базовый;
                - PreparedStatement    наследующий от Statement;
                - CallableStatement    наследующий от PreparedStatement.

            Все классы специализируются для выполнения различных типов запросов:
                - Statement             предназначен для выполнения простых SQL-запросов без параметров;
                                        содержит базовые методы для выполнения запросов и извлечения результатов.
                - PreparedStatement     используется для выполнения SQL-запросов с или без входных параметров;
                                        добавляет методы управления входными параметрами.
                - CallableStatement     используется для вызовов хранимых процедур;
                                        добавляет методы для манипуляции выходными параметрами

       Класс Statement содержит три различных метода выполнения SQL-выражений, которые вызываются в зависимости
    от текста SQL-запроса:
            - executeQuery
            - executeUpdate
            - execute

        executeQuery    - используется в запросах, результатом которых является один единственный набор значений,
                          таких как запросов типа SELECT.

        executeUpdate   - следует использовать
                               - для выполнения операторов управления данными типа INSERT, UPDATE или DELETE
                                 (DML - Data Manipulation Language),
                               - для операторов определения структуры базы данных CREATE TABLE, DROP TABLE
                                 (DDL - Data Definition Language).
                          Результатом выполнения:
                               - операторов INSERT, UPDATE, или DELETE является изменения одной или более строк таблицы
                               - метода executeUpdate является целочисленное значение, определяющее, сколько строк было модифицировано
                                    - для выражений DML, которые не оперируют со строками, возвращаемое executeUpdate значение
                                 всегда равно нулю

        execute         - используется, когда операторы SQL возвращают
                               - более одного набора данных,
                               - более одного счетчика обновлений или и то, и другое.


        Необходимо отметить, что
            - PreparedStatement, имеет свои реализации методов executeQuery, executeUpdate и execute.
                            Объекты PreparedStatement не принимают SQL-выражения в виде аргументов этих методов,
                        так как они уже содержат прекомпилированные SQL-выражения.

            - CallableStatement наследуют методы от PreparedStatement без параметров.
                            использование аргументов в методах executeXXX объектов PreparedStatement и CallableStatement приведет
                        к генерации ошибки SQLException.

        Объекты Statement закрываются автоматически сборщиком мусора.
    Тем не менее рекомендуется закрывать их явно после того, как работа с ними завершена, это позволит освободить ресурсы СУБД
    и проблем с памятью

        Объект Statement считается завершенным, если он выполнился и все его результаты были возвращены.
            - для executeQuery, возвращающий набор данных, оператор считается завершенным, если считаны все строки соответствующего
              объекта ResultSet.
            - для executeUpdate объект завершен сразу же после выполнения метода
            - для execute оператор остается не завершенным до тех пор, пока все наборы данных не будут считаны


        PreparedStatement
            Предварительно компилирует запросы, которые могут содержать входные параметры обозначенные символом '?'

        CallableStatement
            Объект CallableStatement предоставляет унифицированный способ вызова хранимых процедур в СУБД.
            Вызов процедуры осуществляется с результирующим параметром и без него.
        Результирующий параметр - это один из типов выходных (OUT) параметров, являющийся возвращаемым значением хранимой процедуры.



        Объект CallableStatement предоставляет унифицированный способ вызова хранимых процедур в СУБД. Вызов процедуры осуществляется с результирующим параметром и без него. Результирующий параметр - это один из типов выходных (OUT) параметров, являющийся возвращаемым значением хранимой процедуры.

        Синтаксис вызова хранимой процедуры в JDBC показан ниже. Квадратные скобки означают, что то, что находится между ними, необязательно, и сами по себе не являются частью синтаксиса.

        {call имя_процедуры[(?, ?, ...)]}

        // Синтаксис для функции, возвращающей результат:
        {? = call имя_процедуры[(?, ?, ...)]}

        // Синтаксис хранимой процедуры без параметров:
        {call имя_процедуры}
        Первые две формы могут иметь переменное число аргументов на входе (параметры IN), выходе (параметры OUT) или входных и выходных параметров одновременно (INOUT-параметры). Вопросительный знак означает местоположение параметра.

        Метод supportsStoredProcedures() класса DatabaseMetaData позволяет узнать, поддерживает СУБД хранимые процедуры или нет.

        Создание объекта CallableStatement
        Объекты CallableStatement создаются методом prepareCall объекта Connection. Пример, который создает экземпляр CallableStatement, содержащий вызов хранимой процедуры setGoodsData с двумя аргументами и без возвращаемого параметра:

        CallableStatement cstmt = con.prepareCall("{call setGoodsData(?, ?)}");
        Какими именно параметрами (IN, OUT или INOUT) являются знаки вопроса - зависит от самой хранимой процедуры setGoodsData.

        Входные и выходные IN- и OUT-параметры
        Передача значений входных парметров объекта CallableStatement осуществляется с помощью методов setXXX, унаследованных от PreparedStatement. Типы передаваемых значений определяются тем, какой из методов setXXX используется (setString для передачи значений типа String, setInt для передачи значений типа int и т.п.).

        JDBC-типы всех OUT-параметров хранимых процедур должны быть зарегистрирваны перед их вызовом. Регистрация типов данных выходного параметра производится методом registerOutParameter. Только в этом случае после вызова хранимой процедуры CallableStatement.executeQuery() можно получить результаты выполнения с помощью методов getXXX. Необходимо использовать подходящий по типу данных Java метод getXXX в соответствии с зарегистрированным JDBC-типом параметра. Другими словами, registerOutParameter использует JDBC-тип, который подходит к JDBC-типу возвращаемого из значения, а getXXX преобразует его в тип Java.

        Пример регистрации выходных параметров хранимой процедуры и чтение выходных значений. В примере метод getByte извлекает байт из первого выходного параметра, а getBigDecimal возвращает объект BigDecimal (с двумя цифрами после десятичной точки) из второго выходного параметра :

        CallableStatement cstmt = con.prepareCall ("{call getData(?, ?)}");
        cstmt.registerOutParameter(1, java.sql.Types.TINYINT);
        cstmt.registerOutParameter(2, java.sql.Types.DECIMAL, 2);
        // Вызов хранимой процедуры
        cstmt.executeQuery();
        // Чтение выходных данных
        byte x = cstmt.getByte(1);
        java.math.BigDecimal n = cstmt.getBigDecimal(2, 2);
        Чтение выходных параметров
        В связи с ограничениями некоторых СУБД для большей совместимости рекомендуется сначала считывать результаты, сгенерированные вызовом CallableStatement, а затем выходные (OUT) параметры.

        Если объект CallableStatement возвращает несколько объектов ResultSet (с использованием метода execute), то ВСЕ результаты должны быть прочитаны перед первым обращением к выходным параметрам. В этом случае для того, чтобы прочитать все результаты, надо последовательно вызывать методы Statement getResultSet, getUpdateCount и getMoreResults до тех пор, пока не останется больше результатов. После этого значения выходных параметров могут быть извлечены спомощью методов CallableStatement.getXXX.

        Нулевое значение в выходных параметрах, wasNull
        Возращаемое значение в выходном параметре может быть NULL. При этом методы getXXX возвращают null, 0 или false, в зависимости от типа данных.

        Как и в случае с ResultSet, единственным способом узнать, вернула ли процедура 0, false или NULL, является вызов метода wasNull, который возвращает true, если последнее значение, считанное одним из методов getXXX был NULL, и false иначе.

        Входные/выходные параметры INOUT
        Если параметр является одновременно и входным, и выходным (INOUT), то необходимо вызывать как метод setXXX, так и метод registerOutParameter. Метод setXXX устанавливает входное значение параметра, а registerOutParameter регистрирует тип выходного значения.

        Типы входного и выходного значений, зарегистрированных методом registerOutParameter, должны быть одинаковыми. Для чтения выходного значения используется соответствующий метод getXXX. Например, для параметра типа byte нужно использовать метод установки значения setByte, передавать JDBC-тип данных TINYINT методу registerOutParameter и использовать getByte для чтения выходного значения.

        В следующий пример демонстрирует вызов хранимой процедуры rebuildTotal с одним INOUT-параметром. Метод setByte устанавливает значение параметра в 25, которое будет передано хранимой процедуре базе данных как TINYINT. Далее метод registerOutParameter регистрирует 1-ый параметр как TINYINT. После выполнения хранимой процедуры возвращается значение типа TINYINT, которое будет считано методом getByte в виде типа byte языка Java.

        CallableStatement cstmt = con.prepareCall("{call rebuildTotal(?)}");
        // Определение значение параметра
        cstmt.setByte(1, 25);
        // Регистрация выходного параметра
        cstmt.registerOutParameter(1, java.sql.Types.TINYINT);
        cstmt.executeUpdate();
        // Чтение параметра
        byte x = cstmt.getByte(1);
        Если хранимая процедура оформлена функцией, т.е возвращает значение не через параметры, а через оператор "RETURNS", то для вызова используйте "execute" вместо "executeUpdate".

        В отличие от ResultSet, CallableStatement не может считывать большие значения последовательно (в потоке)..
        Escape-последовательности в запросах Statement
        SQL-выражения Statement'ов могут включать escape-последовательности, которые сигнализирует о том, что код выражения должен обрабатываться особо. Escape-последовательности заменяются кодом, специфичным для данной СУБД. Escape-синтаксис независит от типа СУБД

        Cинтаксис escape-последовательности
        Escape-конструкция заключается в фигурные скобки, где определяется ключевое слово и параметры :

        {ключ.слово . . . параметры . . . }
        Ключевое слово индицирует вид Escape-конструкции.

        1. escape-последовательность с символом
        Операция SQL типа LIKE использует шаблонные символы "%" и "_", которые используются для извлечения информации с определенными символами. Чтобы эти символы интерпретировались в SQL-выражении без изменений, необходимо перед ними установить обратный символ слэша "\". Этот специальный символ и называется escape-символом.

        Можно явно определить, какой именно из символов использовать в качестве escape-символа, если в конце запроса ввести следующую конструкцию:

         {escape 'char'}
        В следующем коде осуществляется чтение строки, начинающейся со знака подчеркивания:

        stmt.executeQuery("SELECT name FROM GOODS WHERE NAME LIKE `\_%' {escape `\'};
        2. escape-последовательность с функциией fn
        Практически во всех СУБД есть функции для манипуляции с числами, строками, временем, датой. Эти функции могут использоваться в escape-конструкции с ключевым словом fn, именем функции и ее аргументами. Следующий пример вызывает функцию конкатенации concat с двумя аргументами:

        {fn concat("Hot", "Java")};
        Имя текущего пользователя БД может быть извлечено с помощью следующего вызова:

        {fn user()};
        Скалярные функции могут поддерживаться различными СУБД с немного отличающимся синтаксисом, а некоторыми СУБД могут и не поддерживаться вовсе.

        Для получения списка поддерживаемых СУБД функций можно использовать класс чтения метаданных DatabaseMetaData, у которого метод getNumericFunctions возвращает список имен числовых функций, разделенных запятой, а метод getStringFunctions возвращает строковые функции, и т.д.

        3. escape-последовательность для работы с датой и временам
        Различные СУБД отличаются форматом записи и чтения даты, времени и временного штампа, включающего дату и время (timestamp).

        Формат использование escape-последовательности даты следующий:

        {d 'yyy-mm-dd'}
        где yyyy - это год, mm - месяц, и dd - день. Например, следующая последовательность {d 2015-02-28} будет заменена строкой '28- FEB-15', если СУБД воспринимает именно такой формат даты.

        Аналогичным образом обрабатываются escape-конструкции для типов данных TIME и TIMESTAMP:

        {t 'hh:mm:ss'}
        {ts 'yyy-mm-dd hh:mm:ss.ms'}
        Милисекунда (.ms) в TIMESTAMP может быть опущена.

        4. escape-последовательность с хранимыми процедурами
        Для обращения к хранимой процедуры из JDBC используется либо call, либо ? = call.

        Если СУБД поддерживает хранимые процедуры, то они могут вызываться из JDBC с помощью следующего синтаксиса escape-последовательности:

        // Процедура не возвращает значение
        {call имя_процедуры[(?, ?, . . .)]}

        // Процедура возвращает значение
        {? = call имя_процедуры[(?, ?, . . .)]}



    4. Класс ResultSet представляет результирующий набор данных и обеспечивает приложению построчный доступ к результатам запросов.
       При обработке запроса ResultSet поддерживает указатель на текущую обрабатываемую строку.
       Доступ к данным ResultSet обеспечивает посредством набора get-методов, которые организуют доступ к колонкам текущей строки.

    Основные методы ResultSet:
       absolute(int row)    -   перемещает курсор на заданное число строк от начала,
                                если число положительно, и от конца - если отрицательно
       afterLast()          -   перемещает курсор в конец результирующего набора за последнюю строку
       beforeFirst()	    -   перемещает курсор в начало результирующего набора перед первой строкой
       deleteRow()	        -   удаляет текущую строку из результирующего набора и базы данных
       getMetaData() 	    -   предоставляет объект метаданных для данного ResultSet.
       getRow()             -   возвращает номер текущей строки
       getStatement() 	    -   возвращает экземпляр Statement, который произвел данный результирующий набор
       next()
       previous() 	        -   эти методы позволяют переместиться в результирующем наборе на одну строку вперед или назад.
                                    Во вновь созданном результирующем наборе курсор устанавливается перед первой строкой,
                                поэтому первое обращение к методу next() влечет позиционирование на первую строку.
                                    Эти методы возвращают true, если остается строка для дальнейшего перемещения.
                                    Если открыт поток InputStream для предыдущей строки, он закрывается.
                                    Также очищается цепочка предупреждений SQLWarning
       close()	            -   осуществляет немедленное закрытие ResultSet вручную.
                                обычно этого не нужно, так как закрытие Statement, связанного с ResultSet, автомат закрывает ResultSet.


       Чтобы определить, равно ли значение определенной колонки NULL или нет, необходимо
            - прочитать значение колонки,
            - а затем использовать метод wasNull класса ResultSet для выяснения
                    - если wasNull возвращает значение true, тогда значение равно NULL.

       В случае, если возвращаемое значение NULL, то методы ResultSet.getXXX, равны:
            - null      для методов, которые возвращают объекты
                        (getString, getBigDecimal, getBytes, getDate, getTime, getTimestamp, getAsciiStream,
                        getUnicodeStream, getBinaryStream, getObject)
            - 0         для методов, возвращающих целочисленное или вещественное значения
                        (getByte, getShort, getInt, getLong, getFloat, and getDouble)
            - false     для метода getBoolean


       Для чтения больших объектов LOB (Large Object Bynary) также используется ResultSet.
            - getBytes / getString          возвращают эти данные в виде одного большого массива (байт, символов)
            - Statement.getMaxFieldSize     можно узнать размер объекта

                    byte[] binaryBuffer = null;
                    try {
                            Statement stmt = connection.createStatement();
                            ResultSet rset = stmt.executeQuery(sql);
                            rset.next();
                            binaryBuffer = rset.getBytes(1);
                            rset.close();
                            stmt.close();
                    } catch (SQLException e) {}


            Также большие объекты LOB можно читать с помощью потоков (java.io.InputStream), которые возвращаются
       некоторыми методами ResultSet.
            Следует обратить внимание на то, что к этим потокам надо обращаться сразу, так как они будут закрыты
       при следующем вызове getXXX объекта ResultSet.
            Такое поведение диктуется низкоуровневой реализацией доступа к большим двоичным объектам.

            JDBC API включает три отдельных метода для чтения данных в поток :
                - getBinaryStream       возвращает поток байтов "как есть", без какого-либо предварительного преобразования
                - getAsciiStream        возвращает поток, состоящий из однобайтовых ASCII-символов
                - getUnicodeStream      возвращает поток двухбайтных символов Unicode
            Эти потоки отличаются от обычных потоков Java, которые возвращают нетипизированные байты.

            Пример использование getAsciiStream :
                Statement stmt = connection.createStatement();
                ResultSet rs = st.executeQuery("select book from lib where name = 'Золушка'");
                rs.next();
                Clob clob = rs.getClob(1);
                InputStream is = clob.getAsciiStream();