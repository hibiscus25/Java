
// -------------------------------- Главные задачи, которые решает многопоточность -------------------------------------
            - Одновременно выполняет несколько действий
                    Например:
                                Программа с пользовательским интерфейсом, которая при нажатии на кнопку «Продолжить»:
                                    - внутри программы произойдут вычисления
                                    - пользователь следующий экран интерфейса

                                Если все это осуществлять последовательно, то после нажатия на кнопку «Продолжить»:
                                    - программа зависнет
                                    - пользователь будет видеть экран с кнопкой «Продолжить»
                                      пока не выполняться вычисления  и не начнется отрисовка нового интерфейса

                                Если использовать многопоточность:
                                    - 1-й поток будет выполнять нужные вычисления;
                                    - 2-й поток будет отрисовать интерфейс

                                    Поэтому программа не будет висеть, а пользователь будет переходить между интерфейсами
                                не ожидая внутренних вычислений программы

            - Ускоряет вычисления:
                    Учитывая что сейчас большинство процессоров многоядерные, поэтому список задач могут параллельно решать
                несколько ядер (увеличивая скорость вычисления)



// -------------------------- Проблемы, которые может вызвать использование многопоточности ----------------------------

           — Deadlock               —   ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов,
             взаимная блокировка        занятых друг другом, и ни один из них не может продолжать выполнение

           — Race condition         —   ошибка проектирования многопоточной системы,
             состояние гонки            при которой работа системы зависит от того, в каком порядке выполняются части кода



// -------------------------------------------- ключевое слово VOLATILE ------------------------------------------------
        При создании многопоточных приложений можно столкнуться с двумя серьезными проблемами:
            - в процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных
                    - например:
                            - один поток изменил значение переменной
                            - второй не увидел этого изменения, потому что работал со своей, кэшированной копией переменной

            - в Java операции чтения и записи полей всех типов, КРОМЕ long и double, являются атомарными
                    - например:
                            - в одном потоке меняешь значение  - int
                            - в другом потоке читаешь значение это значение
                            - в результате получаешь:
                                    - либо старое значение int
                                    - либо новое значение int, которое получилось после изменения в потоке 1
                            Никаких «промежуточных вариантов» появиться не может

                    - однако с long и double это не работает (из-за кроссплатформенности):
                            long и double — самые «тяжеловесные» примитивы в Java:    они весят по 64 бита

                                Java-приложение работают абсолютно на всех ОС (Windows, Linux, MacOS....),
                            но в некоторых 32-бит платформах не реализована атомарность чтения и записи 64 бит переменных
                                И такие переменные читаются/записываются в две операции (первые 32 бита, потом еще 32)

                            Соответственно, в этих случаях может возникнуть проблема:
                                - один поток записывает 64-битное значение в переменную Х, и делает он это «в два захода»д;
                                - в это время второй поток пытается прочитать значение, причем делает это как раз посередине,
                                  когда первые 32 бита уже записаны, а вторые — еще нет.
                                - в результате получается некорректное значение

                            Например:
                                - записываем  в переменную число 9223372036854775809
                                        1000000000000000000000000000000000000000000000000000000000000001 (в 2 системе)

                                - первый поток записывает первые 32 бита    -   10000000000000000000000000000000
                                - второй поток считывает эти 32 бита и использует в своих вычислениях
                                - первый поток дописывает вторые 32 бита    -   0000000000000000000000000000001
                                - поэтому возникает ошибка, вместо 9223372036854775809  использовали другое число.

            Чтобы избежать этих 2-ух проблем используют ключевое слово  - volatile
                    - volatile long i
                         - означает, что переменная всегда будет атомарно читаться / записываться
                           даже если это  64-битное double или long
                         - JVM не будет помещать переменную в кэш, поэтому работе потоков со своими локальными копиями исключена



// ---------------------------------------- методы для работы с потоками -----------------------------------------------
        - activeCount()         - возвращается количество активных потоков в группе
        - checkAccess()         - позволяет выполнить проверку на предмет того,
                                  может ли указанный поток быть изменен выполняемым потоком
        - currentThread()       - возвращает результатом ссылку на объект текущего потока
                                  (потока, в котором вызывается метод)
        - enumerate()           - предназначен для копирования в массив ссылок на все активные
                                  потоки в данной группе потоков (и ее подгрупах)
        - getId()               - в качестве результата возвращается идентификатор потока - целое число,
                                  идентифицирующее поток
        - getName()             - в качестве результата возвращает имя потока
        - getPriority()         - возвращает результатом приоритет потока (целое число от 1 до 10)
        - getState()            - в качестве результата возвращается объект, определяющий статус потока
        - getThreadGroup()      - результатом метода является объект, определяющий группу, к которой принадлежит поток
        - holdsLock()           - в качестве результата возвращается логическое значение, определяющее,
                                  удерживает ли метод монитор (специальный объект, используемый для блокировки некоторого
                                  ресурса с целью недопущения обращения к нему сразу нескольких методов)
        - interrupt()           - предназначен для выполнения прерывания потока
        - interrupted()         - используется для проверки того, был ли поток прерван.
                                  при этом меняется статус потока (в отношении прерывания)
        - isAlive()             - метод для определения того, активен ли поток
        - isDaemon()            - проверка потока на предмет того, является ли он демон-потоком
                                  (такие потоки обычно выполняются в фоновом режиме и автоматически завершаются
                                   при завершении главного потока)
        - isInterrupted()       - используется для проверки того, был ли поток прерван.
                                  при этом статус потока (в отношении прерывания) не меняется
        - join()                - вызов метода приводит к тому, что поток, в котором вызывается метод,
                                  ожидает завершение потока, из объекта которого вызывается метод
        - notify()              - при вызове метода один из потоков, находящихся в режиме ожидания
                                  (для получения доступа к ресурсу), переводится в режим выполнения
        - notifyAll()           - при вызове метода все потоки, находящиеся в режиме ожидания
                                  (для получения доступа к ресурсу), переводятся в режим выполнения
        - run()                 - метод с кодом, выполняемым в рамках потока
                                  определяет точку входа в поток
        - setDaemon()           - позволяет определить поток как демон-поток
                                  (особый вид потоков, которые автоматически завершаются при завершении выполнения
                                  главного потока)
        - setName()             - позволяет задать название для потока
        - setPriority()         - присваивает значение приоритета потоку
        - sleep()               - приостанавливает выполнение потока на указанное время (в мс)
        - wait()                - предназначен для перевода потока в режим ожидания
                                  (при получении доступа к ресурсу)
        - yield()               - посылается сигнал диспетчеру потоков, что текущий поток готов уступить использование
                                  процессора в пользу других потоков

