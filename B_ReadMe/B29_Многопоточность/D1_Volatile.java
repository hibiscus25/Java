package B_ReadMe.B29_Многопоточность;

/*      Все действия выполняет процессор
     Но для хранения результатов вычислений используется:
          - основная память
          - аппаратный кэш у процессора
               - эти кэши процессора — своего рода маленький кусочек памяти для более быстрого обращения к данным,
                                       чем обращения к основной памяти
               - минусом хранения в кэше в том, что данные в кэше могут быть не актуальные

        Для решения этой проблемы используется ключевое слово volatile, которое указывает JVM,
     что мы не хотим кэшировать переменную.
        Это позволяет увидеть актуальный результат во всех потоках.
        Кроме того, важно помнить, что volatile — это про видимость, а не про атомарность изменений
*/

public class D1_Volatile {
    public static boolean flag = false;                                     // не выполнится - кэшируем переменную
//    public static volatile boolean flag = false;                          // выполнится - не кэширует переменную

    public static void main(String[] args) throws InterruptedException {
        Runnable run = () -> {
            while(!flag) {}
            System.out.println("Flag is now TRUE");
        };

        new Thread(run).start();
            Thread.sleep(1000);
            flag = true;
    }
}
