Примеры:
    - Exam1    -   обобщенный класс с одним параметром
    - Exam2    -   обобщенный класс с несколькими параметрами

    - Exam3    -   обобщенный конструктор
    - Exam4    -   статический обобщенный метод
    - Exam5    -   нестатического обобщенный метод

    - Exam6    -   суперкласс (generic)    -   наследники (нет)
    - Exam7    -   суперкласс (generic)    -   наследники (generic)
    - Exam8    -   суперкласс (нет)        -   наследники (generic)

    - Exam9    -   интерфейс (generic)     -   класс (generic)
    - Exam10   -   интерфейс (generic)     -   класс (нет)

    - Exam11    -   ограничение <X extends Суперкласс>
    - Exam12    -   ограничение <X extends Суперкласс<Тип параметра>>
    - Exam13    -   ограничение <X extends Интерфейс>
    - Exam14    -   ограничение <X extends Суперкласс & Интерфейс>

    - Exam15        -   <?>                     -   Wildcard              -   обобщенная подстановка
        Exam16
    - Exam17        -   <? extends SuperClass> / <? super SubClass>       -   обобщенные подстановки с ограничениями
        Exam18    -   <? extends SuperClass>    -   Bounded Wildcard            -   ограничение сверху
        Exam19    -   <? super SubClass>        -   Lower bounded wildcard      -   ограничение снизу

    - Exam20        -   Bounded type argument
    - Exam21        -   Wildcard Capture


---------------------------------------------- Generic (Обобщение) -----------------------------------------------------
    1. Обобщения или generics позволяют нам уйти от жесткого определения используемых типов.

    2. При работе с обобщенными типами нужно обратить внимание:
                - значения, используемые для обобщенных параметров, известны на момент компиляции, но после компиляции программы
            в байт-код эта информация стирается (то есть на этапе выполнения программного кода в рамках обобщенного
            класса или метода нельзя явно идентифицировать используемое значение обобщенного параметра (но это можно сделать
            на этапе компиляции)
                - поэтому мы можем объявить в теле метода или в классе объектную переменную, относящуюся к обобщенному типу,
              но не можем создать объект на основе обобщенного типа
                - причина в том, что переменная создается на этапе компиляции, а объект - в процессе выполнения программы.
                - по этой же причине мы можем использовать переменные массива с элементами обобщенного типа, но не можем создать
              массив с элементами обобщенного типа.


    3. Обычно обобщенные классы/методы используются в тех случаях, когда с помощью класса реализуется некоторая структура
        или конструкция, которая имеет универсальные характеристики и слабо зависит от конкретного типа данных, с которыми приходится
        оперировать.


    4. Обобщенные классы могут участвовать в иерархии наследования, выполняя роли:
                - базовых классов
                - наследников суперкласса


    5. Обобщенный интерфейс может использоваться:
                    -   как для создания  обобщенного класса, так и для
                    -   создания класса с конкретными значениями для обобщенных параметров типа


    6. Oграничение обобщений (когда необходимо, чтобы параметр соответствовал только некоторому ограниченному набору типов):
         - для этого применяются ограничения, которые позволяют указать базовый класс, которому должен соответствовать параметр

    Например:
         - <X extends Суперкласс>                   -   обозначающий, что обобщенный тип Х должен быть таким,
                                                        что является подклассом (прямым или опосредованным) класса Суперкласс
                                                            - только Суперкласс и его наследников
         - <X extends Суперкласс<Тип>>              -   кроме ограничения по Суперклассу, дополнительно ограничение по типу
                                                            - только Суперкласс и его наследников с заданным типом
         - <X extends Интерфейс>                    -   ограничение по интерфейсу
                                                            - только класс, который имплементируют заданный интерфейс
         - <X extends Суперкласс & Интерфейс>       -   ограничение по Суперклассу и интерфейсу
                                                            - только Суперкласс и его наследники, которые имплементируют интерфейс


    7.1 Обобщенные подстановки
          - в качестве определения обобщенного параметра используют инструкцию вида
               <?>                        -   сообщая компилятору, что в соответствующем месте используется некоторый
                                              неизвестный обобщенный тип

    7.2 При использовании обобщенных подстановок используются  ограничения:
               <? extends SuperClass>     -   означает, что для параметра обобщенного типа используется неустановленный тип,
                                              являющийся подклассом (прямым или опосредованным) класса SuperClass
               <? super SubClass>         -   означает, что в качестве параметра обобщенного типа может быть класс,
                                              являющийся (через цепочку наследования) суперклассом для класса SubClass


    8. Ограничения generic
            - невозможно создать массив generic'ов :
                - Collection<T> c;                          // ok
                - T[] t;                                    // ok
                - new T[10];                                // Ошибка    - нельзя использовать new

            - невозможно создать массив generic-классов :
                - new ArrayList<List<Integer>>();           // ok
                - List<?>[] la = new List<?>[10];           // Ошибка    - нельзя использовать new