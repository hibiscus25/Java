    Cтруктура:
        - класс Collection;
        - класс Array;
        - интерфейс Collection:
            - интерфейс List   -   максимально похож на Array - работает по индексу
                        - ArrayList()     -   автоматически увеличивается размер массива
                        - Vector()        -   аналогия ArrayList, но методы синхронизированы
                        - LinkedList()    -   упорядоченный список
            - интерфейс Queue  -   очередь
                        - LinkedList      -   упорядоченная очередь
                        - PriorityQueue   -   отсортированная очередь
            - интерфейс Set Collection    -   cохраняет уникальные значения (работает на основе Map)
                        - HashSet         - не упорядоченный
                        - LinkedHashSet   - упорядоченный  (запоминает очередь добавления)
                        - TreeSet         - отсортированный
        - интерфейс Map         -  сохраняет в формате ключ - значение
                        - HashMap         - не упорядоченный
                        - HashTable       - аналогия HashMap, но методы синхронизированы
                        - LinkedHashMap   - упорядоченные (запоминает очередь добавления)
                        - TreeMap         - отсортированный по методу Red-Black Tree

    Сортировка:
        - для сортировки используется интерфейсы Comparator или Comparable


--------------------------------------------------- Collection ---------------------------------------------------------
        1.0  Интерфейс Collection является фундаментальным интерфейсом для классов Java, поддерживающих наборы данных (коллекции),
    в котором объявлены 2 основных метода :
            - add()       -   добавляет элемент к набору и возвращает
                                    - true    -   если набор данных изменился
                                    - false   -   если набор не изменился
                              Например,
                                    - если добавить в множество уже существующий объект, то запрос add() будет проигнорирован,
                                      поскольку по определению множество не может содержать дублирующие объекты.
            - iterator()  -   возвращает объект-итератор, реализующий интерфейс Iterator,
                              который используется для последовательного обращения к элементам набора данных


        1.1 Разработчики библиотеки Java добавили ряд полезных методов (отмечены '+') в интерфейс java.util.Collection<E>,
    которые должны поддерживаться  во всех реализующих его классах:
        - boolean add (Object element)                  -   добавляет элемент в набор
                                                                - true, если в результате вызова метода набор данных изменился
        - Iterator<E> iterator()	                    -   возвращает итератор для обращения к элементам набора данных

        + int size ()                                   -   определение размера набора данных
        + boolean isEmpty()                             -   возвращает значение true, если набор пустой
        + boolean contains (Object obj)                 -   возвращает true, если набор содержит объект, эквивалентный obj
        + boolean containsAll (Collection<?> other)	    -   возвращает true, если текущий набор содержит все объекты набора данных other
        + boolean equals (Object obj)                   -
        + boolean addAll (Collection<? extends E> other)-	добавляет все элементы в набор
                                                                Возвращает true, если в результате вызова метода набор данных изменился
        + boolean remove (Object obj)                   -	удаляет объект obj
                                                                Возвращает true, если в результате вызова метода набор данных изменился
        + boolean removeAll (Collection<?> other)       -   удаляет из текущего набора данных все элементы, содержащиеся в наборе other
                                                                Возвращает true, если в результате вызова метода набор данных изменился
        + void clear ()                                 -   удаляет из текущего набора данных все элементы
        + boolean retainAll (Collection<?> other)       -   удаляет из набора данных элементы, не совпадающие с теми, которые содержатся
                                                            в наборе other.
                                                            Возвращает true, если в результате вызова метода набор данных изменился.
        + Object[] toArray ()                           -   возвращает массив с объектами из набора данных
        + <T> T[] toArray (T[] arrayToFill)             -

        Применение каждым классом, реализующим интерфейс Collection, такого количества стандартных методов было бы слишком
    обременительным.
        Для упрощения процесса их реализации, в классе AbstractCollection оставлены абстрактными только фундаментальные методы:
            - size()
            - iterator()
    а на основе этих методов реализованы все остальные стандартные методы.



    -------------------------------------------------- iterator --------------------------------------------------------
        2.1 интерфейс java.util.Iterator<E>
    Определены следующие три основных метода:
            - boolean hasNext()     -   узнаем, есть ли следующий элемент, и не достигнут ли конец коллекции
                                                - true - если в коллекции имеется следующий элемент
                                          Mетод вызывается перед методом next(), чтобы не получить NoSuchElementException
            - Object next()         -   возвращает следующий элемент
                                          Если достигнут конец набора,то генерируется исключение NoSuchElementException
            - void remove()         -   удаляет текущий элемент, который был получен последним вызовом next()
                                          Метод должен быть вызван сразу же после обращения к элементу.
                                          Если после чтения элемента набор данных изменился, генерирует исключение IllegalStateException

    Перебор коллекции может осуществляться с помощью:
            - Iterator
            - For each
                -   компилятор преобразует цикл "for each" в обычный цикл с итератором
                - цикл "for each" работает с любым объектом, реализующим интерфейс Iterable, в котором объявлен единственный метод
                           public interface Iterable <E>{
                                Iterator <E> iterator();
                           }
                - интерфейс Collection расширяет интерфейс Iterable.
                    - поэтому цикл "for each" можно использовать для любого набора данных из стандартной библиотеки

    Порядок перебора элементов коллекции зависит от типа и набора элементов.
            - если используется объект ArrayList, то итератор начинает с индекса 0 и увеличивает индекс на 1 на каждом шаге
            - если объект имеет тип HashSet, то порядок следования элементов коллекции может оказаться случайным


        2.2 интерфейс  ListIterator
    Имеет больший набор методов и используется классами реализующими интерфейс List, то есть классами LinkedList, ArrayList и др.

    Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:
        - void add(E obj)       -   	вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом next()

        - boolean hasNext()     -	    true, если в коллекции имеется следующий элемент, иначе - false
        - E next()	            -       возвращает следующий элемент
                                            -   если такого нет, то генерируется исключение NoSuchElementException
        - int nextIndex()       -       возвращает индекс следующего элемента
                                            -   если такого нет, то возвращается размер списка

        - boolean hasPrevious() -    	true, если в коллекции имеется предыдущий элемент, иначе - false
        - E previous()          -       возвращает предыдущий элемент
                                            -   если такого нет, то генерируется исключение NoSuchElementException
        - int previousIndex()   -       возвращает индекс предыдущего элемента
                                            -   если такого нет, то возвращается число -1

        - void set(E obj)       -       присваивает текущему элементу, выбранному вызовом методов next() или previous(),
                                                    ссылку на объект obj
        - void remove()	        -       удаляет текущий элемент из списка.
                                            -   таким образом, этот метод должен быть вызван после методов next() или previous(),
                                                иначе будет сгенерировано исключение IllegalStateException



    --------------------------------------------- СПИСОК НАБОРА ДАННЫХ -------------------------------------------------
         - классы реализующие интерфейс Collection (есть и другие)
                -   ArrayList       -   индексируемая последовательность, размер которой может увеличиваться и уменьшаться
                -   LinkedList      -	упорядоченная последовательность, обеспечивающая эффективное выполнение операций
                                        включения или удаления элемента в любой позиции.

                -   PriorityQueue	-   набор, обеспечивающий эффективное удаление наименьшего элемента.

                -   HashSet	        -   неупорядоченный набор, не допускающий дублирования элементов
                -   LinkedHashSet   -	множество, которое помнит порядок, в котором элементы были включены в него.
                -   TreeSet	        -   сортированное множество элементов
                -   EnumSet         -	набор значений нумерованногог типа

         - классы реализующие интерфейс Map
                -   HashMap	        -   карта, которая хранит связи ключ/значение
                -   LinkedHashMap   -	карта, которая помнит порядок включения элементов в него
                -   TreeMap         -	карта, в которой ключи отсортированы
                -   EnumMap	        -   карта, в которой ключи принадлежат нумерованному типу
                -   WeakHashMap	    -   карта, не используемые значения которой могут быть обработаны системой сборки мусора
                -   IdentityHashMap -   карта, для сравнения ключей которой может быть использована операция ==.



------------------------------------------ СПИСОЧНЫЙ МАССИВ ArrayList --------------------------------------------------
        1. Класс ArrayList реализует интерфейс List и может менять свой размер во время исполнения программы,
     при этом не обязательно указывать размерность при создании объекта.
                - элементы ArrayList могут быть абсолютно любых типов в том числе и null.

        2. Можно инициализировать массив на этапе определения:
                        ArrayList<String> list=new ArrayList<>(Arrays.asList(new String[] {"a", "b", "c"}));

        3. методы  ArrayList:
             - size()       -   возвращает размер массива
             - get()        -   метод возвращает элемент массива
             - add()        -   добавляет элемент в массив  ArrayList (также можно в указанное место)
                                        - при вставке в указанное место, остальные элементы перемещаются на одну позицию дальше
             - set()        -   заменяет элемент массива, в аргументе указывается индекс и новое значение элемента
             - indexOf()    -   ищет нужный элемент и возвращает его индекс;
                                        - если несколько одинаковых элементов    -   возвращает индекс первого совпадения
                                        - если нет совпадений                    -   " - 1 "
                                        - если происходит поиск текста           -   чувствительный к регистру
             - contains()   -   возвращает true или false в зависимости наличия элемента в массиве
                                        - если происходит поиск текста          -   чувствительный к регистру
             - remove()     -   удаление элемента массива (по индексу  и по значению)
                                        - если удаляем по значению, удаляется только первое совпадение
                                        - элементы, следующие после удаленного элемента, перемещаются на одну позицию ближе к началу
             - clear()      -   очистка всего массива
             - toArray()    -   конвертирует набор элементов в обычный массив

        4. интерфейс  java.util.List
     Является интерфейсом и его следует использовать вместо ArrayList следующим образом :
             List<String> list = new ArrayList<>();
                     - тип ArrayList заменен на List, но в объявлении оставлен new ArrayList()
                     - является рекомендуемым способом

     Интерфейс List реализует более общий интерфейс коллекции Collection.

     Пример:
             List<Integer> list = Arrays.asList(1, 2, 5, 9, 11);
             System.out.println (numlist.get(2) + "");                   // 5
                 - недостаток в том, что если определить массив таким образом, то уже нельзя вставлять или удалять элементы,
                   хотя можно изменять существующие  элементы
                           list.set(2, 33);                          // так можно
                           list.add(34);                             // нельзя, ошибка во время исполнения



------------------------------------------ СВЯЗАННЫЙ МАССИВ LinkedList -------------------------------------------------
        1. Отличие LinkedList от ArrayList:
                -  ArrayList - это реализованный на основе массива список объектов
                -  LinkedList — это связный список объектов

        2. LinkedList выполняет вставку и удаление элементов в списке за постоянное время
   (само определение позиции для вставки или удаления не рассматривается).
                - если в алгоритме предусмотрена активная работа (вставка/удаление) в середине списка или в случаях,
              когда необходимо гарантированное время добавления элемента в список, то целесообразно использовать LinkedList.
                - но в большинстве случаев LinkedList проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций

        3. LinkedList — реализует интерфейсы List, Dequeue, Queue и является представителем двунаправленного списка,
   где каждый элемент структуры содержит указатели на предыдущий и следующий элементы.
            Итератор поддерживает обход в обе стороны.
            LinkedList реализует методы получения, удаления и вставки в начало, середину и конец списка,
        а также позволяет добавлять любые элементы, в том числе и null.

        4. КОНСТРУКТОРЫ LinkedList
                - LinkedList()                                          -       создает пустой список
                - LinkedList(Collection<? extends E> collection)        -       создает список,
                                                                                в который добавляет все элементы коллекции collection

        5. Для создания нового LinkedList объекта можно использовать один из конструкторов
                например:
                            List<String> list = new LinkedList<String>();
                                -   созданный объект list, содержит свойства header и size
                                            -   header — это псевдоэлемент списка, его значение всегда равное null, а его свойства:
                                                            -  next     -   всегда указывают на первый элемент списка
                                                            -  prev     -   всегда указываюта на последний элемент списка
                                                    - так как список вновь созданного объекта пустой, поэтому
                                                  свойства next и prev указывают сами на себя (т.е. на элемент header)
                                                      Следовательно, выполняется тождество:
                                                               header.next = header.prev = header;

        6. ДОБАВЛЕНИЕ ЭЛЕМЕНТА
                - add(value)        -   добавление
                - addFirst(value)   -   добавление в начало списка
                - addLast(value)    -   добавление в конец списка

           Класс LinkedList включает статический внутренний класс Entry, с помощью которого создаются новые элементы.
                                private static class Entry<E>{
                                    E element;
                                    Entry<E> next;
                                    Entry<E> prev;

                                    Entry(E element, Entry<E> next, Entry<E> prev){
                                        this.element = element;
                                        this.next = next;
                                        this.prev = prev;
                                    }
                                }

           Для добавления нового элемента в LinkedList необходимо выполнить две итерации:
                   -    создать экземпляр класса Entry;
                   -    переопределить указатели на предыдущий и следующий элемент

        7. МЕТОДЫ LinkedList
                   -    addFirst() / offerFirst()       -	добавляет элемент в начало списка
                   -    addLast() / offerLast()         -	добавляет элемент в конец списка
                   -    removeFirst() / pollFirst()	    -   удаляет первый элемент из начала списка
                   -    removeLast() / pollLast()       -	удаляет последний элемент из конца списка
                   -    getFirst() / peekFirst()        -	получает первый элемент
                   -    getLast() / peekLast()          -	получает последний элемент



------------------------------------------ НАБОР ДАННЫХ ИНТЕРФЕЙСА Set -------------------------------------------------
     1. Реализация интерфейса Set представляет собой неупорядоченную коллекцию, которая не может содержать дублирующие данные

     2. МЕТОДЫ интерфейса Set
          -   add(Object o)             -   	добавление элемента в коллекцию, если он отсутствует
                                                    -   возвращает true, если элемент добавлен, если нет - false
          -   addAll(Collection c)	    -       добавление элементов коллекции, если они отсутствуют
          -   clear()                   -       очистка коллекции
          -   contains(Object o)        -       проверка присутствия элемента в наборе
                                                    -   возвращает true, если элемент найден
          -   containsAll(Collection c) -	    проверка присутсвия коллекции в наборе
                                                    -   возвращает true, если все элементы содержатся в наборе
          -   equals(Object o)          -   	проверка на равенство
          -   hashCode()	            -       получение hashCode набора
          -   isEmpty()	                -       проверка наличия элементов
                                                    -   возвращает true если в коллекции нет ни одного элемента
          -   iterator()	            -       функция получения итератора коллекции
          -   remove(Object o)	        -       удаление элемента из набора
          -   removeAll(Collection c)	-       удаление из набора всех элементов переданной коллекции
          -   retainAll(Collection c)	-       удаление элементов, не принадлежащих переданной коллекции
          -   size()	                -       количество элементов коллекции
          -   toArray()	                -       преобразование набора в массив элементов
          -   toArray(T[] a)	        -       Преобразование набора в массив элементов
                                                В отличии от предыдущего метода, который возвращает массив объектов типа Object,
                                                данный метод возвращает массив объектов типа, переданного в параметре

     3. К семейству интерфейса Set относятся:
            -   HashSet
            -   TreeSet
            -   LinkedHashSet

        В множествах Set разные реализации используют разный порядок хранения элементов
            -   HashSet         -    порядок элементов оптимизирован для быстрого поиска
            -   LinkedHashSet   -    хранит элементы в порядке добавления
            -   TreeSet         -    объекты хранятся отсортированными по возрастанию (при хранении примитивных данных)


     ---------------------------------------------- НАБОР ДАННЫХ HashSet -----------------------------------------------
         4.1. КОНСТРУКТОРЫ
                -   public HashSet();                                           // Создание пустого набора с начальной емкостью (16)
                                                                                   и со значением коэффициента загрузки (0.75) по умолчанию

                -   public HashSet(Collection c);                               // Создание множества из элементов коллекции

                -   public HashSet(int initialCapacity);                        // Создание множества с указанной начальной емкостью
                                                                                   и со значением коэффициента загрузки по умолчанию (0.75)

                -   public HashSet(int initialCapacity, float loadFactor);      // Создание множества с указанными начальной емкостью
                                                                                   и коэффициентом загрузки

         4.2. HashSet содержит методы аналогично ArrayList
                Исключением является метод add(Object o), который добавляет объект только в том случае, если он отсутствует.
                    - если объект добавлен, то метод add возвращает значение — true, в противном случае false.

         4.3. Разное:
                - порядок добавления записей в набор непредсказуемый
                - HashSet использует хэширование для ускорения выборки

         4.4 СИНХРОНИЗАЦИЯ:
                - Реализация HashSet не синхронизируется.
                    - поэтому если многократные потоки получают доступ к набору хеша одновременно,
               а один или несколько потоков должны изменять набор, то он должен быть синхронизирован внешне.
                    - эту процедуру лучше всего выполнить во время создания, чтобы предотвратить случайный несинхронизируемый
               доступ к набору:
                           Set<E> set = Collections.synchronizedSet(new HashSet<E>());


     ---------------------------------------------- НАБОР ДАННЫХ LinkedHashSet -----------------------------------------
         Класс LinkedHashSet наследует HashSet, не добавляя никаких новых методов, и поддерживает связный список элементов набора
     в том порядке, в котором они вставлялись.
         Это позволяет организовать упорядоченную итерацию вставки в набор.

         5.1 КОНСТРУКТОРЫ:
              -   public LinkedHashSet()                                       // Создание пустого набора с начальной емкостью (16)
                                                                               и со значением коэффициента загрузки (0.75) по умолчанию

              -   public LinkedHashSet(Collection c)                           // Создание множества из элементов коллекции

              -   public LinkedHashSet(int initialCapacity)                    // Создание множества с указанной начальной емкостью
                                                                               и со значением коэффициента загрузки по умолчанию (0.75)

              -   public LinkedHashSet(int initialCapacity, float loadFactor)  // Создание множества с указанными начальной емкостью
                                                                               и коэффициентом загрузки

         5.2 СИНХРОНИЗАЦИЯ
              Также, как и HashSet, LinkedHashSet не синхронизируется.
              Поэтому процедура синхронизации аналогична HashSet
                       Set<E> set = Collections.synchronizedSet(new LinkedHashSet<E>());


     ------------------------------------------- НАБОР ДАННЫХ TreeSet --------------------------------------------------
            Класс TreeSet создаёт коллекцию, которая для хранения элементов использует дерево.
        Объекты хранятся в отсортированном порядке по возрастанию.

         6.1 КОНСТРУКТОРЫ:
              -   TreeSet()                                              // создание пустого древовидного набора, с сортировкой согласно
                                                                         естественному упорядочиванию его элементов

              -   TreeSet(Collection<? extends E> c)                     // создание древовидного набора, содержащего элементы
                                                                         в указанном наборе, с сортировкой согласно естественному
                                                                         упорядочиванию его элементов

              -   TreeSet(Comparator<? super E> comparator)              // создание пустого древовидного набора, с сортировкой
                                                                         согласно comparator

              -   TreeSet(SortedSet<E> s)                                // создание древовидного набора, содержащего те же самые элементы
                                                                         и использующего то же самое упорядочивание в качестве
                                                                         указанного сортированного набора

         6.2 МЕТОДЫ
              - boolean add(Object o)
              - boolean addAll(Collection<? extends E> c)
              - Object ceiling(Object o)
              - void clear()
              - TreeSet clone()
              - Comparator<? super E> comparator()
              - boolean contains(Object o)
              - Iterator<Object> descendingIterator()
              - NavigableSet<Object> descendingSet()
              - Object first()
              - Object floor(Object o)
              - SortedSet<E> headSet(E e)
              - NavigableSet<E> headSet(E e, boolean inclusive)
              - Object higher(Object o)
              - boolean isEmpty()
              - Iterator<E> iterator()
                     - E last()
                     - E lower(E e)
                     - E pollFirst()
                     - E pollLast()
              - boolean remove(Object o)
              - int size()
              - Spliterator<E> spliterator()
              - NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
              - SortedSet<E> subSet(E fromElement, E toElement)
              - SortedSet<E> tailSet(E fromElement)
              - NavigableSet<E> tailSet(E fromElement, boolean inclusive)



------------------------------------------ НАБОР ДАННЫХ ИНТЕРФЕЙСА Map -------------------------------------------------
    1. Интерфейс Map располагается на вершине иерархии в Java Collection.
            -   предоставляя разработчику базовые методы для работы с данными вида «ключ — значение».

    2. Наиболее часто используемые методы интерфейса Map
            -   void clear()                                        -   очистка хеш-таблицы
            -   boolean containsKey(Object key)                     -   функция проверки присутствия объекта по ключу
            -   boolean containsValue(Object value)                 -   функция проверки присутствия объекта по значению
            -   Set<Map.Entry<K,V>> entrySet()                      -   функция получения объекта в виде коллекции Set
            -   boolean equals(Object object)                       -   функция сравнения с объектом object
            -   Object get(Object key)                              -   функция получения записи по ключу
            -   boolean isEmpty()                                   -   функция проверки наличия записей
            -   Set<K> keySet()                                     -   функция получения записей в виде коллекции Set
            -   void put(K key, V value)                            -   функция добавления записи
            -   void putAll(Map<? extends K,? extends V> t)	        -   функция добавления записей
            -   void remove(Object key)                             -   метод удаления объекта по ключу key
            -   boolean remove(Object key, Object value)            -   функция удаления записи по соответствию значений ключа и значения
            -   void replace(K key, V value)                        -   замена значения value для записи с ключом key
            -   boolean replace(K key, V oldValue, V newValue)      -   замена значения oldValue на newValue для записи с ключом key
            -   int size()                                          -   функция определения количества записей в хеш-таблице
            -   Collection<V> values()                              -   получение значений записей в виде коллекции



    ---------------------------------------------------- HASHTABLE -----------------------------------------------------
            Класс Hashtable позволяет реализовывать структуру данных типа hash-таблица, содержащую пары вида "ключ - значение".
                    - значение "null" в качестве значения или ключа использовать нельзя.
                    - Hashtable является синхронизированной, т.е. почти все методы помечены как synchronized, в связи с чем могут
                      быть проблемы с производительностью.

           Экземпляр Hashtable включает два параметра, влияющие на его производительность.
                    - начальная емкость
                            - формируется на этапе создания объекта
                    - коэффициент загрузки
                            - определяет объем информации, по достижению которого емкость Hashtable автоматически будет увеличена
                            - обычно, значение  коэффициента загрузки равно 0.75
                            - более высокие значения уменьшают издержки пространства, но увеличивают стоимость времени поиска записи

           3.1. КОНСТРУКТОРЫ
                    -   Hashtable()                                         -   создание хеш-таблицы с емкостью по умолчанию (11 записей)
                                                                                и коэффициент загрузки по умолчанию (0.75)

                    -   Hashtable(int initialCapacity)                      -   создание хеш-таблицы с указанной начальной емкостью
                                                                                и коэффициентом загрузки по умолчанию (0.75)

                    -   Hashtable(int initialCapacity, float loadFactor)    -   создание хеш-таблицы с указанной начальной емкостью
                                                                                и указанным коэффициентом загрузки.

                    -   Hashtable(Map<? extends K,? extends V> t)           -   создание хеш-таблицы с указанными параметрами

           3.2. ДОПОЛНИТЕЛЬНЫЕ МЕТОДЫ
                    Hashtable реализует все методы интерфейса Map и включает дополнительно следующие методы:
                        -   Объект clone()	                    -   создание копии хеш-таблицы
                        -   boolean contains(Object value)      -   функция проверки присутствия объекта value в хеш-таблице
                        -   Enumeration<V> elements()           -   получение ключей хеш-таблицы в виде объекта Enumeration
                        -   Enumeration<K> keys()               -   функция получения ключей хеш-таблицы в виде объекта Enumeration
                        -   void rehash()                       -   реорганизация hash ключей и увеличение емкости



    ------------------------------------------- НАБОР ДАННЫХ HASHMAP ---------------------------------------------------
        Набор данных HashMap является альтернативой Hashtable.
            Основными отличиями от Hashtable являются то, что HashMap:
                -   не синхронизирован и
                -   позволяет использовать null как в качестве ключа, так и значения

           Также как и Hashtable, коллекция HashMap не является упорядоченной:
                -   порядок хранения элементов зависит от хэш-функции.

           Реализация HashMap обеспечивает постоянно-разовую производительность для основных операций (get и put).

           У экземпляра HashMap есть два параметра, влияющие на его производительность:
                - начальная емкость (число блоков в хэш - таблице.  Она определяется при создании хэш - таблице)
                - коэффициент загрузки

           4. КОНСТРУКТОРЫ
                  -   HashMap()	                                       -    по умолчанию значение начальной емкости (16)
                                                                            и коэффициентом загрузки (0.75)

                  -   HashMap(int initialCapacity)	                   -    по умолчанию значение коэффициента загрузки (0.75)
                                                                            и начальной емкостью initialCapacity

                  -   HashMap(int initialCapacity, float loadFactor)   -    используемые значения начальной емкости initialCapacity
                                                                            и коэффициентом загрузки loadFactor

                  -   HashMap(Map<? extends K,? extends V> m)          -    конструктор с определением структуры согласно объекту-параметра


    ----------------------------------------- ХЭШ - ТАБЛИЦЫ LINKEDHASHMAP ----------------------------------------------
            LinkedHashMap — это упорядоченная реализация хэш-таблицы, в которой имеются двунаправленные связи между элементами
    подобно LinkedList
            Это преимущество имеет и недостаток — увеличение памяти, которое занимет коллекция.

            5. КОНСТРУКТОРЫ
                -   LinkedHashMap()	                                       -    по умолчанию значение начальной емкости (16)
                                                                                и коэффициента загрузки (0.75)
                -   LinkedHashMap(int initialCapacity)	                   -    по умолчанию значение коэффициентом загрузки (0.75)
                                                                                и начальной емкостью initialCapacity
                -   LinkedHashMap(int initialCapacity, float loadFactor)    -   используемое значение начальной емкости initialCapacity
                                                                                и коэффициента загрузки loadFactor
                -   LinkedHashMap(int initialCapacity, float loadFactor,
                                    boolean accessOrder)                    -	Используемые значения начальной емкости initialCapacity
                                                                                и коэффициентом загрузки loadFactor.
                                                                                accessOrder
                                                                                    - the ordering mode - true for access-order,
                                                                                    - false for insertion-order

                -   LinkedHashMap(Map<? extends K,? extends V> m)           -   конструктор с определением структуры согласно
                                                                                объекта-параметра


    -------------------------------------------- НАБОР ДАННЫХ TREEMAP --------------------------------------------------
         TreeMap, как и LinkedHashMap, является упорядоченным набором данных.
                - по-умолчанию, TreeMap сортируется по ключам с использованием принципа "natural ordering"
                - но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается
                  в качестве параметра при создании объекта TreeMap.

         6.КОНСТРУКТОРЫ
            -   TreeMap()	                                    -   без упорядочивания данных (using the natural ordering of its keys)
            -   TreeMap(Comparator<? super K> comparator)	    -   с созданием объекта с упорядочиванием значений согласно comparator
            -   TreeMap(Map<? extends K,? extends V> m)	        -   с определением структуры согласно объекту-параметра
            -   TreeMap(SortedMap<K,? extends V> m)	            -   с определением структуры и сортировки согласно объекту-параметра